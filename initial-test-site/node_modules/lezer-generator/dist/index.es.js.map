{"version":3,"file":"index.es.js","sources":["../src/node.ts","../src/error.ts","../src/grammar.ts","../src/token.ts","../src/parse.ts","../src/hash.ts","../src/automaton.ts","../src/encode.ts","../src/build.ts"],"sourcesContent":["export class Node {\n  constructor(readonly start: number) {}\n}\n\nexport class GrammarDeclaration extends Node {\n  constructor(start: number,\n              readonly rules: readonly RuleDeclaration[],\n              readonly topRules: RuleDeclaration[],\n              readonly tokens: TokenDeclaration | null,\n              readonly context: ContextDeclaration | null,\n              readonly externalTokens: readonly ExternalTokenDeclaration[],\n              readonly externalSpecializers: readonly ExternalSpecializeDeclaration[],\n              readonly precedences: PrecDeclaration | null,\n              readonly mainSkip: Expression | null,\n              readonly scopedSkip: readonly {expr: Expression, rules: readonly RuleDeclaration[]}[],\n              readonly dialects: readonly Identifier[],\n              readonly grammars: readonly ExternalGrammarDeclaration[],\n              readonly externalProps: readonly ExternalPropDeclaration[],\n              readonly autoDelim: boolean) {\n    super(start)\n  }\n  toString() { return Object.values(this.rules).join(\"\\n\") }\n}\n\nexport class RuleDeclaration extends Node {\n  constructor(start: number,\n              readonly id: Identifier,\n              readonly props: readonly Prop[],\n              readonly params: readonly Identifier[],\n              readonly expr: Expression) {\n    super(start)\n  }\n  toString() {\n    return this.id.name + (this.params.length ? `<${this.params.join()}>` : \"\") + \" -> \" + this.expr\n  }\n}\n\nexport class PrecDeclaration extends Node {\n  constructor(start: number,\n              readonly items: readonly {id: Identifier, type: \"left\" | \"right\" | \"cut\" | null}[]) {\n    super(start)\n  }\n}\n\nexport class TokenPrecDeclaration extends Node {\n  constructor(start: number,\n              readonly items: readonly (NameExpression | LiteralExpression)[]) {\n    super(start)\n  }\n}\n\nexport class TokenConflictDeclaration extends Node {\n  constructor(start: number,\n              readonly a: NameExpression | LiteralExpression,\n              readonly b: NameExpression | LiteralExpression) {\n    super(start)\n  }\n}\n\nexport class TokenDeclaration extends Node {\n  constructor(start: number,\n              readonly precedences: readonly TokenPrecDeclaration[],\n              readonly conflicts: readonly TokenConflictDeclaration[],\n              readonly rules: readonly RuleDeclaration[],\n              readonly literals: readonly LiteralDeclaration[]) {\n    super(start)\n  }\n}\n\nexport class LiteralDeclaration extends Node {\n  constructor(start: number,\n              readonly literal: string,\n              readonly props: readonly Prop[]) { super(start) }\n}\n\nexport class ContextDeclaration extends Node {\n  constructor(start: number,\n              readonly id: Identifier,\n              readonly source: string) { super(start) }\n}\n\nexport class ExternalTokenDeclaration extends Node {\n  constructor(start: number,\n              readonly id: Identifier,\n              readonly source: string,\n              readonly tokens: readonly {id: Identifier, props: readonly Prop[]}[]) {\n    super(start)\n  }\n}\n\nexport class ExternalSpecializeDeclaration extends Node {\n  constructor(start: number,\n              readonly type: \"extend\" | \"specialize\",\n              readonly token: Expression,\n              readonly id: Identifier,\n              readonly source: string,\n              readonly tokens: readonly {id: Identifier, props: readonly Prop[]}[]) {\n    super(start)\n  }\n}\n\nexport class ExternalGrammarDeclaration extends Node {\n  constructor(start: number,\n              readonly id: Identifier,\n              readonly externalID: Identifier,\n              readonly source: string | null) {\n    super(start)\n  }\n}\n\nexport class ExternalPropDeclaration extends Node {\n  constructor(start: number,\n              readonly id: Identifier,\n              readonly externalID: Identifier,\n              readonly source: string) {\n    super(start)\n  }\n}\n\nexport class Identifier extends Node {\n  constructor(start: number, readonly name: string) {\n    super(start)\n  }\n  toString() { return this.name }\n}\n\nexport class Expression extends Node {\n  walk(f: (expr: Expression) => Expression): Expression { return f(this) }\n  eq(_other: Expression): boolean { return false }\n  prec!: number\n}\n\nExpression.prototype.prec = 10\n\nexport class NameExpression extends Expression {\n  constructor(start: number, readonly namespace: Identifier | null, readonly id: Identifier, readonly args: readonly Expression[]) {\n    super(start)\n  }\n  toString() { return this.id.name + (this.args.length ? `<${this.args.join()}>` : \"\") }\n  eq(other: NameExpression) {\n    return (this.namespace ? other.namespace != null && other.namespace.name == this.namespace.name : !other.namespace) &&\n      this.id.name == other.id.name && exprsEq(this.args, other.args)\n  }\n  walk(f: (expr: Expression) => Expression): Expression {\n    let args = walkExprs(this.args, f)\n    return f(args == this.args ? this : new NameExpression(this.start, this.namespace, this.id, args))\n  }\n}\n\nexport class SpecializeExpression extends Expression {\n  constructor(start: number, readonly type: string, readonly props: readonly Prop[],\n              readonly token: Expression, readonly content: Expression) { super(start) }\n  toString() { return `@${this.type}[${this.props.join(\",\")}]<${this.token}, ${this.content}>` }\n  eq(other: SpecializeExpression) {\n    return this.type == other.type && Prop.eqProps(this.props, other.props) && exprEq(this.token, other.token) &&\n      exprEq(this.content, other.content)\n  }\n  walk(f: (expr: Expression) => Expression): Expression {\n    let token = this.token.walk(f), content = this.content.walk(f)\n    return f(token == this.token && content == this.content ? this : new SpecializeExpression(this.start, this.type, this.props, token, content))\n  }\n}\n\nexport class InlineRuleExpression extends Expression {\n  constructor(start: number, readonly rule: RuleDeclaration) { super(start) }\n\n  toString() {\n    let rule = this.rule\n    return `${rule.id}${rule.props.length ? `[${rule.props.join(\",\")}]` : \"\"} { ${rule.expr} }`\n  }\n  eq(other: InlineRuleExpression) {\n    let rule = this.rule, oRule = other.rule\n    return exprEq(rule.expr, oRule.expr) && rule.id.name == oRule.id.name && Prop.eqProps(rule.props, oRule.props)\n  }\n  walk(f: (expr: Expression) => Expression): Expression {\n    let rule = this.rule, expr = rule.expr.walk(f)\n    return f(expr == rule.expr ? this :\n             new InlineRuleExpression(this.start, new RuleDeclaration(rule.start, rule.id, rule.props, [], expr)))\n  }\n}\n\nexport class ChoiceExpression extends Expression {\n  constructor(start: number, readonly exprs: readonly Expression[]) {\n    super(start)\n  }\n  toString() { return this.exprs.map(e => maybeParens(e, this)).join(\" | \") }\n  eq(other: ChoiceExpression) {\n    return exprsEq(this.exprs, other.exprs)\n  }\n  walk(f: (expr: Expression) => Expression): Expression {\n    let exprs = walkExprs(this.exprs, f)\n    return f(exprs == this.exprs ? this : new ChoiceExpression(this.start, exprs))\n  }\n}\n\nChoiceExpression.prototype.prec = 1\n\nexport class SequenceExpression extends Expression {\n  constructor(start: number, readonly exprs: readonly Expression[], readonly markers: readonly (readonly ConflictMarker[])[]) {\n    super(start)\n  }\n  toString() { return this.exprs.map(e => maybeParens(e, this)).join(\" \") }\n  eq(other: SequenceExpression) {\n    return exprsEq(this.exprs, other.exprs) && this.markers.every((m, i) => {\n      let om = other.markers[i]\n      return m.length == om.length && m.every((x, i) => x.eq(om[i]))\n    })\n  }\n  walk(f: (expr: Expression) => Expression): Expression {\n    let exprs = walkExprs(this.exprs, f)\n    return f(exprs == this.exprs ? this : new SequenceExpression(this.start, exprs, this.markers))\n  }\n}\n\nSequenceExpression.prototype.prec = 2\n\nexport class ConflictMarker extends Node {\n  constructor(start: number, readonly id: Identifier, readonly type: \"ambig\" | \"prec\") {\n    super(start)\n  }\n\n  toString() { return (this.type == \"ambig\" ? \"~\" : \"!\") + this.id.name }\n\n  eq(other: ConflictMarker) { return this.id.name == other.id.name && this.type == other.type }\n}\n\nexport class RepeatExpression extends Expression {\n  constructor(start: number, readonly expr: Expression, readonly kind: \"?\" | \"*\" | \"+\") {\n    super(start)\n  }\n  toString() { return maybeParens(this.expr, this) + this.kind }\n  eq(other: RepeatExpression) {\n    return exprEq(this.expr, other.expr) && this.kind == other.kind\n  }\n  walk(f: (expr: Expression) => Expression): Expression {\n    let expr: Expression = this.expr.walk(f)\n    return f(expr == this.expr ? this : new RepeatExpression(this.start, expr, this.kind))\n  }\n}\n\nRepeatExpression.prototype.prec = 3\n\nexport class LiteralExpression extends Expression {\n  // value.length is always > 0\n  constructor(start: number, readonly value: string) {\n    super(start)\n  }\n  toString() { return JSON.stringify(this.value) }\n  eq(other: LiteralExpression) { return this.value == other.value }\n}\n\nexport class SetExpression extends Expression {\n  constructor(start: number, readonly ranges: [number, number][], readonly inverted: boolean) {\n    super(start)\n  }\n  toString() {\n    return `[${this.inverted ? \"^\" : \"\"}${this.ranges.map(([a, b]) => {\n      return String.fromCodePoint(a) + (b == a + 1 ? \"\" : \"-\" + String.fromCodePoint(b))\n    })}]`\n  }\n  eq(other: SetExpression) {\n    return this.inverted == other.inverted && this.ranges.length == other.ranges.length &&\n      this.ranges.every(([a, b], i) => { let [x, y] = other.ranges[i]; return a == x && b == y })\n  }\n}\n\nexport class AnyExpression extends Expression {\n  constructor(start: number) {\n    super(start)\n  }\n  toString() { return \"_\" }\n  eq() { return true }\n}\n\nfunction walkExprs(exprs: readonly Expression[], f: (expr: Expression) => Expression): readonly Expression[] {\n  let result: Expression[] | null = null\n  for (let i = 0; i < exprs.length; i++) {\n    let expr = exprs[i].walk(f)\n    if (expr != exprs[i] && !result) result = exprs.slice(0, i)\n    if (result) result.push(expr)\n  }\n  return result || exprs\n}\n\nexport function exprEq(a: Expression, b: Expression): boolean {\n  return a.constructor == b.constructor && a.eq(b as any)\n}\n\nexport function exprsEq(a: readonly Expression[], b: readonly Expression[]) {\n  return a.length == b.length && a.every((e, i) => exprEq(e, b[i]))\n}\n\nexport class Prop extends Node {\n  constructor(start: number, readonly at: boolean, readonly name: string, readonly value: readonly PropPart[]) { super(start) }\n\n  eq(other: Prop) {\n    return this.name == other.name && this.value.length == other.value.length &&\n      this.value.every((v, i) => v.value == other.value[i].value && v.name == other.value[i].name)\n  }\n\n  toString() {\n    let result = (this.at ? \"@\" : \"\") + this.name\n    if (this.value.length) {\n      result += \"=\"\n      for (let {name, value} of this.value)\n        result += name ? `{${name}}` : /[^\\w-]/.test(value!) ? JSON.stringify(value) : value\n    }\n    return result\n  }\n\n  static eqProps(a: readonly Prop[], b: readonly Prop[]) {\n    return a.length == b.length && a.every((p, i) => p.eq(b[i]))\n  }\n}\n\nexport class PropPart extends Node {\n  constructor(start: number, readonly value: string | null, readonly name: string | null) { super(start) }\n}\n\nfunction maybeParens(node: Expression, parent: Expression) {\n  return node.prec < parent.prec ? \"(\" + node.toString() + \")\" : node.toString()\n}\n","/// The type of error raised when the parser generator finds an issue.\nexport class GenError extends Error {}\n","import {Term as T} from \"lezer/dist/constants\"\nimport {GenError} from \"./error\"\n\nconst enum TermFlag {\n  // This term is a terminal\n  Terminal = 1,\n  // This is the top production\n  Top = 2,\n  // This represents end-of-file\n  Eof = 4,\n  // This should be preserved, even if it doesn't occur in any rule\n  Preserve = 8,\n  // Rules used for * and + constructs\n  Repeated = 16,\n  // Rules explicitly marked as [inline]\n  Inline = 32\n}\n\nexport type Props = {[name: string]: string}\n\nexport function hasProps(props: Props) {\n  for (let _p in props) return true\n  return false\n}\n\nlet termHash = 0\n\nexport class Term {\n  hash = ++termHash // Used for sorting and hashing during parser generation\n  id = -1 // Assigned in a later stage, used in actual output\n  // Filled in only after the rules are simplified, used in automaton.ts\n  rules: Rule[] = []\n\n  constructor(readonly name: string,\n              private flags: number,\n              readonly nodeName: string | null,\n              readonly props: Props = {}) {}\n\n  toString() { return this.name }\n  get nodeType() { return this.top || this.nodeName != null || hasProps(this.props) || this.repeated }\n  get terminal() { return (this.flags & TermFlag.Terminal) > 0 }\n  get eof() { return (this.flags & TermFlag.Eof) > 0 }\n  get error() { return \"error\" in this.props }\n  get top() { return (this.flags & TermFlag.Top) > 0 }\n  get interesting() { return this.flags > 0 || this.nodeName != null }\n  get repeated() { return (this.flags & TermFlag.Repeated) > 0 }\n  set preserve(value: boolean) { this.flags = value ? this.flags | TermFlag.Preserve : this.flags & ~TermFlag.Preserve }\n  get preserve() { return (this.flags & TermFlag.Preserve) > 0 }\n  set inline(value: boolean) { this.flags = value ? this.flags | TermFlag.Inline : this.flags & ~TermFlag.Inline }\n  get inline() { return (this.flags & TermFlag.Inline) > 0 }\n  cmp(other: Term) { return this.hash - other.hash }\n}\n\nexport class TermSet {\n  terms: Term[] = []\n  // Map from term names to Term instances\n  names: {[name: string]: Term} = Object.create(null)\n  eof: Term\n  error: Term\n  tops: Term[] = []\n\n  constructor() {\n    this.eof = this.term(\"␄\", null, TermFlag.Terminal | TermFlag.Eof)\n    this.error = this.term(\"⚠\", \"⚠\", TermFlag.Preserve)\n  }\n\n  term(name: string, nodeName: string | null, flags: number = 0, props: Props = {}) {\n    let term = new Term(name, flags, nodeName, props)\n    this.terms.push(term)\n    this.names[name] = term\n    return term\n  }\n\n  makeTop(nodeName: string | null, props: Props) : Term {\n    const term = this.term(\"@top\", nodeName, TermFlag.Top, props)\n    this.tops.push(term)\n    return term\n  }\n\n  makeTerminal(name: string, nodeName: string | null, props = {}) {\n    return this.term(name, nodeName, TermFlag.Terminal, props)\n  }\n\n  makeNonTerminal(name: string, nodeName: string | null, props = {}) {\n    return this.term(name, nodeName, 0, props)\n  }\n\n  makeRepeat(name: string) {\n    return this.term(name, null, TermFlag.Repeated)\n  }\n\n  uniqueName(name: string) {\n    for (let i = 0;; i++) {\n      let cur = i ? `${name}-${i}` : name\n      if (!this.names[cur]) return cur\n    }\n  }\n\n  finish(rules: readonly Rule[]) {\n    for (let rule of rules) rule.name.rules.push(rule)\n\n    this.terms = this.terms.filter(t => t.terminal || t.preserve || rules.some(r => r.name == t || r.parts.includes(t)))\n\n    let names: {[id: number]: string} = {}\n    let nodeTypes = [this.error]\n\n    this.error.id = T.Err\n    let nextID = T.Err + 1\n\n    // Assign ids to terms that represent node types\n    for (let term of this.terms) if (term.id < 0 && term.nodeType && !term.repeated) {\n      term.id = nextID++\n      nodeTypes.push(term)\n    }\n    // Put all repeated terms after the regular node types\n    let minRepeatTerm = nextID\n    for (let term of this.terms) if (term.repeated) {\n      term.id = nextID++\n      nodeTypes.push(term)\n    }\n    // Then comes the EOF term\n    this.eof.id = nextID++\n    // And then the remaining (non-node, non-repeat) terms.\n    for (let term of this.terms) {\n      if (term.id < 0) term.id = nextID++\n      if (term.name) names[term.id] = term.name\n    }\n    if (nextID >= 0xfffe) throw new GenError(\"Too many terms\")\n\n    return {nodeTypes, names, minRepeatTerm, maxTerm: nextID - 1}\n  }\n}\n\nexport function cmpSet<T>(a: readonly T[], b: readonly T[], cmp: (a: T, b: T) => number) {\n  if (a.length != b.length) return a.length - b.length\n  for (let i = 0; i < a.length; i++) {\n    let diff = cmp(a[i], b[i])\n    if (diff) return diff\n  }\n  return 0\n}\n\nconst none: readonly any[] = []\n\nexport class Conflicts {\n  constructor(readonly precedence: number, readonly ambigGroups: readonly string[] = none, readonly cut = 0) {}\n\n  join(other: Conflicts) {\n    if (this == Conflicts.none || this == other) return other\n    if (other == Conflicts.none) return this\n    return new Conflicts(Math.max(this.precedence, other.precedence), union(this.ambigGroups, other.ambigGroups),\n                         Math.max(this.cut, other.cut))\n  }\n\n  cmp(other: Conflicts) {\n    return this.precedence - other.precedence || cmpSet(this.ambigGroups, other.ambigGroups, (a, b) => a < b ? -1 : a > b ? 1 : 0) ||\n      this.cut - other.cut\n  }\n\n  static none = new Conflicts(0)\n}\n\nexport function union<T>(a: readonly T[], b: readonly T[]): readonly T[] {\n  if (a.length == 0 || a == b) return b\n  if (b.length == 0) return a\n  let result = a.slice()\n  for (let value of b) if (!a.includes(value)) result.push(value)\n  return result.sort()\n}\n\nlet ruleID = 0\n\nexport class Rule {\n  id = ruleID++\n\n  constructor(readonly name: Term,\n              readonly parts: readonly Term[],\n              readonly conflicts: readonly Conflicts[],\n              readonly skip: Term) {}\n\n  cmp(rule: Rule) {\n    return this.id - rule.id\n  }\n\n  cmpNoName(rule: Rule) {\n    return this.parts.length - rule.parts.length ||\n      this.skip.hash - rule.skip.hash ||\n      this.parts.reduce((r, s, i) => r || s.cmp(rule.parts[i]), 0) ||\n      cmpSet(this.conflicts, rule.conflicts, (a, b) => a.cmp(b))\n  }\n\n  toString() {\n    return this.name + \" -> \" + this.parts.join(\" \")\n  }\n\n  get isRepeatWrap() {\n    return this.name.repeated && this.parts.length == 2 && this.parts[0] == this.name\n  }\n\n  sameReduce(other: Rule) {\n    return this.name == other.name && this.parts.length == other.parts.length && this.isRepeatWrap == other.isRepeatWrap\n  }\n}\n","import {Term, union} from \"./grammar\"\nimport {GenError} from \"./error\"\n\nexport const MAX_CHAR = 0xfffe\n\nexport class Edge {\n  constructor(readonly from: number, readonly to: number, readonly target: State) {}\n\n  toString() {\n    return `-> ${this.target.id}[label=${JSON.stringify(\n      this.from < 0 ? \"ε\" : charFor(this.from) +\n        (this.to > this.from + 1 ? \"-\" + charFor(this.to - 1) : \"\"))}]`\n  }\n}\n\nfunction charFor(n: number) {\n  return n > MAX_CHAR ? \"∞\" : n >= 0xd800 && n < 0xdfff ? \"\\\\u{\" + n.toString(16) + \"}\" : String.fromCharCode(n)\n}\n\nlet stateID = 1\n\nexport class State {\n  edges: Edge[] = []\n\n  constructor(readonly accepting: Term[] = [], readonly id = stateID++) {}\n\n  edge(from: number, to: number, target: State) {\n    this.edges.push(new Edge(from, to, target))\n  }\n\n  nullEdge(target: State) { this.edge(-1, -1, target) }\n\n  compile() {\n    let labeled: {[id: string]: State} = Object.create(null), localID = 0\n    return explore(this.closure().sort((a, b) => a.id - b.id))\n\n    function explore(states: State[]) {\n      let newState = labeled[ids(states)] =\n        new State(states.reduce((a: readonly Term[], s: State) => union(a, s.accepting), []) as Term[], localID++)\n      let out: Edge[] = []\n      for (let state of states) for (let edge of state.edges) {\n        if (edge.from >= 0) out.push(edge)\n      }\n      let transitions = mergeEdges(out)\n      for (let merged of transitions) {\n        let targets = merged.targets.sort((a, b) => a.id - b.id)\n        newState.edge(merged.from, merged.to, labeled[ids(targets)] || explore(targets))\n      }\n      return newState\n    }\n  }\n\n  closure() {\n    let result: State[] = []\n    function explore(state: State): void {\n      if (result.includes(state)) return\n      // States with only epsilon edges and no accepting term that\n      // isn't also in the next states are left out to help reduce the\n      // number of unique state combinations\n      if (state.edges.some(e => e.from >= 0) ||\n          (state.accepting.length > 0 && !state.edges.some(e => sameSet(state.accepting, e.target.accepting))))\n        result.push(state)\n      for (let edge of state.edges) if (edge.from < 0) explore(edge.target)\n    }\n    explore(this)\n    return result\n  }\n\n  findConflicts(occurTogether: (a: Term, b: Term) => boolean): Conflict[] {\n    let conflicts: Conflict[] = [], cycleTerms = this.cycleTerms()\n    function add(a: Term, b: Term, soft: number, aEdges: Edge[], bEdges?: Edge[]) {\n      if (a.id < b.id) { [a, b] = [b, a]; soft = -soft }\n      let found = conflicts.find(c => c.a == a && c.b == b)\n      if (!found) conflicts.push(new Conflict(a, b, soft, exampleFromEdges(aEdges), bEdges && exampleFromEdges(bEdges)))\n      else if (found.soft != soft) found.soft = 0\n    }\n    this.reachable((state, edges) => {\n      if (state.accepting.length == 0) return\n      for (let i = 0; i < state.accepting.length; i++)\n        for (let j = i + 1; j < state.accepting.length; j++)\n          add(state.accepting[i], state.accepting[j], 0, edges)\n      state.reachable((s, es) => {\n        if (s != state) for (let term of s.accepting) {\n          let hasCycle = cycleTerms.includes(term)\n          for (let orig of state.accepting) if (term != orig)\n            add(term, orig, hasCycle || cycleTerms.includes(orig) || !occurTogether(term, orig) ?  0 : 1, edges, edges.concat(es))\n        }\n      })\n    })\n    return conflicts\n  }\n\n  cycleTerms(): Term[] {\n    let work: State[] = []\n    this.reachable(state => {\n      for (let {target} of state.edges) work.push(state, target)\n    })\n\n    let table: Map<State, State[]> = new Map\n    let haveCycle: State[] = []\n    for (let i = 0; i < work.length;) {\n      let from = work[i++], to = work[i++]\n      let entry = table.get(from)\n      if (!entry) table.set(from, entry = [])\n      if (entry.includes(to)) continue\n      if (from == to) {\n        if (!haveCycle.includes(from)) haveCycle.push(from)\n      } else {\n        for (let next of entry) work.push(from, next)\n        entry.push(to)\n      }\n    }\n\n    let result: Term[] = []\n    for (let state of haveCycle) {\n      for (let term of state.accepting) {\n        if (!result.includes(term)) result.push(term)\n      }\n    }\n    return result\n  }\n\n  reachable(f: (s: State, edges: Edge[]) => void) {\n    let seen: State[] = [], edges: Edge[] = []\n    ;(function explore(s: State) {\n      f(s, edges)\n      seen.push(s)\n      for (let edge of s.edges) if (!seen.includes(edge.target)) {\n        edges.push(edge)\n        explore(edge.target)\n        edges.pop()\n      }\n    })(this)\n  }\n\n  toString() {\n    let out = \"digraph {\\n\"\n    this.reachable(state => {\n      if (state.accepting.length)\n        out += `  ${state.id} [label=${JSON.stringify(state.accepting.join())}];\\n`\n      for (let edge of state.edges)\n        out += `  ${state.id} ${edge};\\n`\n    })\n    return out + \"}\"\n  }\n\n  // Tokenizer data is represented as a single flat array. This\n  // contains regions for each tokenizer state. Region offsets are\n  // used to identify states.\n  //\n  // Each state is laid out as:\n  //  - Token group mask\n  //  - Offset of the end of the accepting data\n  //  - Number of outgoing edges in the state\n  //  - Pairs of token masks and term ids that indicate the accepting\n  //    states, sorted by precedence\n  //  - Triples for the edges: each with a low and high bound and the\n  //    offset of the next state.\n  toArray(groupMasks: {[id: number]: number}, precedence: readonly number[]) {\n    let offsets: number[] = [] // Used to 'link' the states after building the arrays\n    let data: number[] = []\n    this.reachable(state => {\n      let start = data.length\n      let acceptEnd = start + 3 + state.accepting.length * 2\n      offsets[state.id] = start\n      data.push(state.stateMask(groupMasks), acceptEnd, state.edges.length)\n      state.accepting.sort((a, b) => precedence.indexOf(a.id) - precedence.indexOf(b.id))\n      for (let term of state.accepting)\n        data.push(term.id, groupMasks[term.id] || 0xffff)\n      for (let edge of state.edges) data.push(edge.from, edge.to, -edge.target.id - 1)\n    })\n    // Replace negative numbers with resolved state offsets\n    for (let i = 0; i < data.length; i++) if (data[i] < 0) data[i] = offsets[-data[i] - 1]\n    if (data.length > 2**16) throw new GenError(\"Tokenizer tables too big to represent with 16-bit offsets.\")\n    return Uint16Array.from(data)\n  }\n\n  stateMask(groupMasks: {[id: number]: number}) {\n    let mask = 0\n    this.reachable(state => {\n      for (let term of state.accepting) mask |= (groupMasks[term.id] || 0xffff)\n    })\n    return mask\n  }\n}\n\nexport class Conflict {\n  constructor(readonly a: Term, readonly b: Term,\n              // Conflicts between two non-cyclic tokens are marked as\n              // 'soft', with a negative number if a is shorter than\n              // b, and a positive if b is shorter than a.\n              public soft: number,\n              readonly exampleA: string, readonly exampleB?: string) {}\n}\n\nfunction exampleFromEdges(edges: readonly Edge[]) {\n  let str = \"\"\n  for (let i = 0; i < edges.length; i++) str += String.fromCharCode(edges[i].from)\n  return str\n}\n\nfunction ids(states: State[]) {\n  let result = \"\"\n  for (let state of states) result += (result.length ? \"-\" : \"\") + state.id\n  return result\n}\n\nfunction sameSet<T>(a: readonly T[], b: readonly T[]) {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i]) return false\n  return true\n}\n\nclass MergedEdge {\n  constructor(readonly from: number, readonly to: number, readonly targets: State[]) {}\n}\n\n// Merge multiple edges (tagged by character ranges) into a set of\n// mutually exclusive ranges pointing at all target states for that\n// range\nfunction mergeEdges(edges: Edge[]): MergedEdge[] {\n  let separate: number[] = [], result: MergedEdge[] = []\n  for (let edge of edges) {\n    if (!separate.includes(edge.from)) separate.push(edge.from)\n    if (!separate.includes(edge.to)) separate.push(edge.to)\n  }\n  separate.sort((a, b) => a - b)\n  for (let i = 1; i < separate.length; i++) {\n    let from = separate[i - 1], to = separate[i]\n    let found: State[] = []\n    for (let edge of edges) if (edge.to > from && edge.from < to) {\n      for (let target of edge.target.closure()) if (!found.includes(target))\n        found.push(target)\n    }\n    if (found.length) result.push(new MergedEdge(from, to, found))\n  }\n  return result\n}\n","import {GrammarDeclaration, RuleDeclaration, PrecDeclaration,\n        TokenPrecDeclaration, TokenConflictDeclaration, TokenDeclaration, LiteralDeclaration,\n        ContextDeclaration, ExternalTokenDeclaration,\n        ExternalSpecializeDeclaration, ExternalGrammarDeclaration, ExternalPropDeclaration, Identifier,\n        Expression, NameExpression, ChoiceExpression, SequenceExpression, LiteralExpression,\n        RepeatExpression, SetExpression, InlineRuleExpression, Prop, PropPart,\n        SpecializeExpression, AnyExpression, ConflictMarker} from \"./node\"\nimport {GenError} from \"./error\"\n\n// Note that this is the parser for grammar files, not the generated parser\n\nlet word = /[\\w_-]+/gy\n// Some engines (specifically SpiderMonkey) have still not implemented \\p\ntry { word = /[\\p{Alphabetic}\\d_-]+/ugy } catch (_) {}\n\nconst none: readonly any[] = []\n\nexport class Input {\n  type = \"sof\"\n  value: any = null\n  start = 0\n  end = 0\n\n  constructor(readonly string: string,\n              readonly fileName: string | null = null) {\n    this.next()\n  }\n\n  lineInfo(pos: number) {\n    for (let line = 1, cur = 0;;) {\n      let next = this.string.indexOf(\"\\n\", cur)\n      if (next > -1 && next < pos) {\n        ++line\n        cur = next + 1\n      } else {\n        return {line, ch: pos - cur}\n      }\n    }\n  }\n\n  message(msg: string, pos: number = -1): string {\n    let posInfo = this.fileName || \"\"\n    if (pos > -1) {\n      let info = this.lineInfo(pos)\n      posInfo += (posInfo ? \" \" : \"\") + info.line + \":\" + info.ch\n    }\n    return posInfo ? msg + ` (${posInfo})` : msg\n  }\n\n  raise(msg: string, pos: number = -1): never {\n    throw new GenError(this.message(msg, pos))\n  }\n\n  match(pos: number, re: RegExp) {\n    let match = re.exec(this.string.slice(pos))\n    return match ? pos + match[0].length : -1\n  }\n\n  next() {\n    let start = this.match(this.end, /^(\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/)\n    if (start == this.string.length) return this.set(\"eof\", null, start, start)\n\n    let next = this.string[start]\n    if (next == '\"') {\n      let end = this.match(start + 1, /^(\\\\.|[^\"])*\"/)\n      if (end == -1) this.raise(\"Unterminated string literal\", start)\n      return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end)\n    } else if (next == \"'\") {\n      let end = this.match(start + 1, /^(\\\\.|[^'])*'/)\n      if (end == -1) this.raise(\"Unterminated string literal\", start)\n      return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end)\n    } else if (next == \"@\") {\n      word.lastIndex = start + 1\n      let m = word.exec(this.string)\n      if (!m) return this.raise(\"@ without a name\", start)\n      return this.set(\"at\", m[0], start, start + 1 + m[0].length)\n    } else if ((next == \"$\" || next == \"!\") && this.string[start + 1] == \"[\") {\n      let end = this.match(start + 2, /^(?:\\\\.|[^\\]])*\\]/)\n      if (end == -1) this.raise(\"Unterminated character set\", start)\n      return this.set(\"set\", this.string.slice(start + 2, end - 1), start, end)\n    } else if (/[\\[\\]()!~+*?{}<>\\.,|:$=]/.test(next)) {\n      return this.set(next, null, start, start + 1)\n    } else {\n      word.lastIndex = start\n      let m = word.exec(this.string)\n      if (!m) return this.raise(\"Unexpected character \" + JSON.stringify(next), start)\n      return this.set(\"id\", m[0], start, start + m[0].length)\n    }\n  }\n\n  set(type: string, value: any, start: number, end: number) {\n    this.type = type\n    this.value = value\n    this.start = start\n    this.end = end\n  }\n\n  eat(type: string, value: any = null) {\n    if (this.type == type && (value == null || this.value === value)) {\n      this.next()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  unexpected(): never {\n    return this.raise(`Unexpected token '${this.string.slice(this.start, this.end)}'`, this.start)\n  }\n\n  expect(type: string, value: any = null) {\n    let val = this.value\n    if (this.type != type || !(value == null || val === value)) this.unexpected()\n    this.next()\n    return val\n  }\n\n  parse() {\n    return parseGrammar(this)\n  }\n}\n\nfunction parseGrammar(input: Input) {\n  let start = input.start\n  let rules: RuleDeclaration[] = []\n  let prec: PrecDeclaration | null = null\n  let tokens: TokenDeclaration | null = null\n  let mainSkip: Expression | null = null\n  let scopedSkip: {expr: Expression, rules: readonly RuleDeclaration[]}[] = []\n  let dialects: Identifier[] = []\n  let context: ContextDeclaration | null = null\n  let external: ExternalTokenDeclaration[] = []\n  let specialized: ExternalSpecializeDeclaration[] = []\n  let nested: ExternalGrammarDeclaration[] = []\n  let props: ExternalPropDeclaration[] = []\n  let tops: RuleDeclaration[] = []\n  let autoDelim = false\n\n  while (input.type != \"eof\") {\n    let start = input.start\n    if (input.type == \"at\" && input.value == \"top\") {\n      input.next()\n      if (input.type as any != \"id\") input.raise(`Top rules must have a name`, input.start)\n      let name = parseIdent(input)\n      if (tops.length && name.name === '@top') {\n        input.raise(`Unnamed secondary @top declaration`, input.start)\n      }\n      tops.push(parseRule(input, name))\n    } else if (input.type == \"at\" && input.value == \"tokens\") {\n      if (tokens) input.raise(`Multiple @tokens declaractions`, input.start)\n      else tokens = parseTokens(input)\n    } else if (input.eat(\"at\", \"context\")) {\n      if (context) input.raise(`Multiple @context declarations`, start)\n      let id = parseIdent(input)\n      input.expect(\"id\", \"from\")\n      let source = input.expect(\"string\")\n      context = new ContextDeclaration(start, id, source)\n    } else if (input.eat(\"at\", \"external\")) {\n      if (input.eat(\"id\", \"tokens\")) external.push(parseExternalTokens(input, start))\n      else if (input.eat(\"id\", \"grammar\")) nested.push(parseExternalGrammar(input, start))\n      else if (input.eat(\"id\", \"prop\")) props.push(parseExternalProp(input, start))\n      else if (input.eat(\"id\", \"extend\")) specialized.push(parseExternalSpecialize(input, \"extend\", start))\n      else if (input.eat(\"id\", \"specialize\")) specialized.push(parseExternalSpecialize(input, \"specialize\", start))\n      else input.unexpected()\n    } else if (input.eat(\"at\", \"dialects\")) {\n      input.expect(\"{\")\n      for (let first = true; !input.eat(\"}\"); first = false) {\n        if (!first) input.eat(\",\")\n        dialects.push(parseIdent(input))\n      }\n    } else if (input.type == \"at\" && input.value == \"precedence\") {\n      if (prec) input.raise(`Multiple precedence declarations`, input.start)\n      prec = parsePrecedence(input)\n    } else if (input.eat(\"at\", \"detectDelim\")) {\n      autoDelim = true\n    } else if (input.eat(\"at\", \"skip\")) {\n      let skip = parseBracedExpr(input)\n      if (input.type == \"{\") {\n        input.next()\n        let scoped = []\n        while (!input.eat(\"}\")) scoped.push(parseRule(input))\n        scopedSkip.push({expr: skip, rules: scoped})\n      } else {\n        if (mainSkip) input.raise(`Multiple top-level skip declarations`, input.start)\n        mainSkip = skip\n      }\n    } else {\n      rules.push(parseRule(input))\n    }\n  }\n  if (!tops.length) return input.raise(`Missing @top declaration`)\n  return new GrammarDeclaration(start, rules, tops, tokens, context, external, specialized, prec,\n                                mainSkip, scopedSkip, dialects, nested, props, autoDelim)\n}\n\nfunction parseRule(input: Input, named?: Identifier) {\n  let start = named ? named.start : input.start\n  let id = named || parseIdent(input)\n  let props = parseProps(input)\n  let params: Identifier[] = []\n  if (input.eat(\"<\")) while (!input.eat(\">\")) {\n    if (params.length) input.expect(\",\")\n    params.push(parseIdent(input))\n  }\n  let expr = parseBracedExpr(input)\n  return new RuleDeclaration(start, id, props, params, expr)\n}\n\nfunction parseProps(input: Input) {\n  if (input.type != \"[\") return none\n  let props = []\n  input.expect(\"[\")\n  while (!input.eat(\"]\")) {\n    if (props.length) input.expect(\",\")\n    props.push(parseProp(input))\n  }\n  return props\n}\n\nfunction parseProp(input: Input) {\n  let start = input.start, value = [], name = input.value, at = input.type == \"at\"\n  if (!input.eat(\"at\") && !input.eat(\"id\")) input.unexpected()\n  if (input.eat(\"=\")) for (;;) {\n    if (input.type == \"string\" || input.type == \"id\") {\n      value.push(new PropPart(input.start, input.value, null))\n      input.next()\n    } else if (input.eat(\".\")) {\n      value.push(new PropPart(input.start, \".\", null))\n    } else if (input.eat(\"{\")) {\n      value.push(new PropPart(input.start, null, input.expect(\"id\")))\n      input.expect(\"}\")\n    } else {\n      break\n    }\n  }\n  return new Prop(start, at, name, value)\n}\n\nfunction parseBracedExpr(input: Input): Expression {\n  input.expect(\"{\")\n  let expr = parseExprChoice(input)\n  input.expect(\"}\")\n  return expr\n}\n\nconst SET_MARKER = \"\\ufdda\" // (Invalid unicode character)\n\nfunction parseExprInner(input: Input): Expression {\n  let start = input.start\n  if (input.eat(\"(\")) {\n    let expr = parseExprChoice(input)\n    input.expect(\")\")\n    return expr\n  } else if (input.type == \"string\") {\n    let value = input.value\n    input.next()\n    if (value.length == 0) return new SequenceExpression(start, none, [none, none])\n    return new LiteralExpression(start, value)\n  } else if (input.eat(\"id\", \"_\")) {\n    return new AnyExpression(start)\n  } else if (input.type == \"set\") {\n    let content = input.value, invert = input.string[input.start] == \"!\"\n    let unescaped = readString(content.replace(/\\\\.|-|\"/g, (m: string) => {\n      return m == \"-\" ? SET_MARKER : m == '\"' ? '\\\\\"' : m\n    }))\n    let ranges: [number, number][] = []\n    for (let pos = 0; pos < unescaped.length;) {\n      let code = unescaped.codePointAt(pos)!\n      pos += code > 0xffff ? 2 : 1\n      if (pos < unescaped.length - 1 && unescaped[pos] == SET_MARKER) {\n        let end = unescaped.codePointAt(pos + 1)!\n        pos += end > 0xffff ? 3 : 2\n        if (end < code) input.raise(\"Invalid character range\", input.start)\n        addRange(input, ranges, code, end + 1)\n      } else {\n        addRange(input, ranges, code, code + 1)\n      }\n    }\n    input.next()\n    return new SetExpression(start, ranges.sort((a, b) => a[0] - b[0]), invert)\n  } else if (input.type == \"at\" && (input.value == \"specialize\" || input.value == \"extend\")) {\n    let {start, value} = input\n    input.next()\n    let props = parseProps(input)\n    input.expect(\"<\")\n    let token = parseExprChoice(input), content\n    if (input.eat(\",\")) {\n      content = parseExprChoice(input)\n    } else if (token instanceof LiteralExpression) {\n      content = token\n    } else {\n      input.raise(`@${value} requires two arguments when its first argument isn't a literal string`)\n    }\n    input.expect(\">\")\n    return new SpecializeExpression(start, value, props, token, content)\n  } else if (input.type == \"[\") {\n    let rule = parseRule(input, new Identifier(start, \"_anon\"))\n    if (rule.params.length) input.raise(`Inline rules can't have parameters`, rule.start)\n    return new InlineRuleExpression(start, rule)\n  } else {\n    let id = parseIdent(input)\n    if (input.type == \"[\" || input.type == \"{\") {\n      let rule = parseRule(input, id)\n      if (rule.params.length) input.raise(`Inline rules can't have parameters`, rule.start)\n      return new InlineRuleExpression(start, rule)\n    } else {\n      let namespace = null\n      if (input.eat(\".\")) {\n        namespace = id\n        id = parseIdent(input)\n      }\n      return new NameExpression(start, namespace, id, parseArgs(input))\n    }\n  }\n}\n\nfunction parseArgs(input: Input) {\n  let args = []\n  if (input.eat(\"<\")) while (!input.eat(\">\")) {\n    if (args.length) input.expect(\",\")\n    args.push(parseExprChoice(input))\n  }\n  return args\n}\n\nfunction addRange(input: Input, ranges: [number, number][], from: number, to: number) {\n  if (!ranges.every(([a, b]) => b <= from || a >= to))\n    input.raise(\"Overlapping character range\", input.start)\n  ranges.push([from, to])\n}\n\nfunction parseExprSuffix(input: Input): Expression {\n  let start = input.start\n  let expr = parseExprInner(input)\n  for (;;) {\n    let kind = input.type\n    if (input.eat(\"*\") || input.eat(\"?\") || input.eat(\"+\"))\n      expr = new RepeatExpression(start, expr, kind as \"*\" | \"+\" | \"?\")\n    else\n      return expr\n  }\n}\n\nfunction endOfSequence(input: Input) {\n  return input.type == \"}\" || input.type == \")\" || input.type == \"|\" || input.type == \"/\" ||\n    input.type == \"/\\\\\" || input.type == \"{\" || input.type == \",\" || input.type == \">\"\n}\n\nfunction parseExprSequence(input: Input) {\n  let start = input.start, exprs: Expression[] = [], markers = [none]\n  do {\n    // Add markers at this position\n    for (;;) {\n      let localStart = input.start, markerType!: \"ambig\" | \"prec\"\n      if (input.eat(\"~\")) markerType = \"ambig\"\n      else if (input.eat(\"!\")) markerType = \"prec\"\n      else break\n      markers[markers.length - 1] =\n        markers[markers.length - 1].concat(new ConflictMarker(localStart, parseIdent(input), markerType))\n    }\n    if (endOfSequence(input)) break\n    exprs.push(parseExprSuffix(input))\n    markers.push(none)\n  } while (!endOfSequence(input))\n  if (exprs.length == 1 && markers.every(ms => ms.length == 0)) return exprs[0]\n  return new SequenceExpression(start, exprs, markers)\n}\n\nfunction parseExprChoice(input: Input) {\n  let start = input.start, left = parseExprSequence(input)\n  if (!input.eat(\"|\")) return left\n  let exprs: Expression[] = [left]\n  do { exprs.push(parseExprSequence(input)) }\n  while (input.eat(\"|\"))\n  return new ChoiceExpression(start, exprs)\n}\n\nfunction parseIdent(input: Input) {\n  if (input.type != \"id\") input.unexpected()\n  let start = input.start, name = input.value\n  input.next()\n  return new Identifier(start, name)\n}\n\nfunction parsePrecedence(input: Input) {\n  let start = input.start\n  input.next()\n  input.expect(\"{\")\n  let items: {id: Identifier, type: \"left\" | \"right\" | \"cut\" | null}[] = []\n  while (!input.eat(\"}\")) {\n    if (items.length) input.eat(\",\")\n    items.push({\n      id: parseIdent(input),\n      type: input.eat(\"at\", \"left\") ? \"left\" : input.eat(\"at\", \"right\") ? \"right\" : input.eat(\"at\", \"cut\") ? \"cut\" : null\n    })\n  }\n  return new PrecDeclaration(start, items)\n}\n\nfunction parseTokens(input: Input) {\n  let start = input.start\n  input.next()\n  input.expect(\"{\")\n  let tokenRules: RuleDeclaration[] = []\n  let literals: LiteralDeclaration[] = []\n  let precedences: TokenPrecDeclaration[] = []\n  let conflicts: TokenConflictDeclaration[] = []\n  while (!input.eat(\"}\")) {\n    if (input.type == \"at\" && input.value == \"precedence\") {\n      precedences.push(parseTokenPrecedence(input))\n    } else if (input.type == \"at\" && input.value == \"conflict\") {\n      conflicts.push(parseTokenConflict(input))\n    } else if (input.type == \"string\") {\n      literals.push(new LiteralDeclaration(input.start, input.expect(\"string\"), parseProps(input)))\n    } else {\n      tokenRules.push(parseRule(input))\n    }\n  }\n  return new TokenDeclaration(start, precedences, conflicts, tokenRules, literals)\n}\n\nfunction parseTokenPrecedence(input: Input) {\n  let start = input.start\n  input.next()\n  input.expect(\"{\")\n  let tokens: (LiteralExpression | NameExpression)[] = []\n  while (!input.eat(\"}\")) {\n    if (tokens.length) input.expect(\",\")\n    let expr = parseExprInner(input)\n    if (expr instanceof LiteralExpression || expr instanceof NameExpression)\n      tokens.push(expr)\n    else\n      input.raise(`Invalid expression in token precedences`, expr.start)\n  }\n  return new TokenPrecDeclaration(start, tokens)\n}\n\nfunction parseTokenConflict(input: Input) {\n  let start = input.start\n  input.next()\n  input.expect(\"{\")\n  let a = parseExprInner(input)\n  if (!(a instanceof LiteralExpression || a instanceof NameExpression))\n    input.raise(`Invalid expression in token conflict`, a.start)\n  input.eat(\",\")\n  let b = parseExprInner(input)\n  if (!(b instanceof LiteralExpression || b instanceof NameExpression))\n    input.raise(`Invalid expression in token conflict`, b.start)\n  input.expect(\"}\")\n  return new TokenConflictDeclaration(start, a, b)\n}\n\nfunction parseExternalTokenSet(input: Input) {\n  let tokens: {id: Identifier, props: readonly Prop[]}[] = []\n  input.expect(\"{\")\n  while (!input.eat(\"}\")) {\n    if (tokens.length) input.eat(\",\")\n    let id = parseIdent(input)\n    let props = parseProps(input)\n    tokens.push({id, props})\n  }\n  return tokens\n}\n\nfunction parseExternalTokens(input: Input, start: number) {\n  let id = parseIdent(input)\n  input.expect(\"id\", \"from\")\n  let from = input.expect(\"string\")\n  return new ExternalTokenDeclaration(start, id, from, parseExternalTokenSet(input))\n}\n\nfunction parseExternalSpecialize(input: Input, type: \"extend\" | \"specialize\", start: number) {\n  input.expect(\"{\")\n  let token = parseExprChoice(input)\n  input.expect(\"}\")\n  let id = parseIdent(input)\n  input.expect(\"id\", \"from\")\n  let from = input.expect(\"string\")\n  return new ExternalSpecializeDeclaration(start, type, token, id, from, parseExternalTokenSet(input))\n}\n\nfunction parseExternalGrammar(input: Input, start: number) {\n  let externalID = parseIdent(input)\n  let id = input.eat(\"id\", \"as\") ? parseIdent(input) : externalID\n  let from = null\n  if (input.eat(\"id\", \"from\")) from = input.expect(\"string\")\n  else input.expect(\"id\", \"empty\")\n  return new ExternalGrammarDeclaration(start, id, externalID, from)\n}\n\nfunction parseExternalProp(input: Input, start: number) {\n  let externalID = parseIdent(input)\n  let id = input.eat(\"id\", \"as\") ? parseIdent(input) : externalID\n  input.expect(\"id\", \"from\")\n  let from = input.expect(\"string\")\n  return new ExternalPropDeclaration(start, id, externalID, from)\n}\n\nfunction readString(string: string) {\n  let point = /\\\\(?:u\\{([\\da-f]+)\\}|u([\\da-f]{4})|x([\\da-f]{2})|([ntbrf0])|(.))|./yig\n  let out = \"\", m\n  while (m = point.exec(string)) {\n    let [all, u1, u2, u3, single, unknown] = m\n    if (u1 || u2 || u3)\n      out += String.fromCodePoint(parseInt(u1 || u2 || u3, 16))\n    else if (single)\n      out += single == \"n\" ? \"\\n\" : single == \"t\" ? \"\\t\" : single == \"0\" ? \"\\0\" : single == \"r\" ? \"\\r\" : single == \"f\" ? \"\\f\" : \"\\b\"\n    else if (unknown)\n      out += unknown\n    else\n      out += all\n  }\n  return out\n}\n","export function hash(a: number, b: number): number { return (a << 5) + a + b }\n\nexport function hashString(h: number, s: string) {\n  for (let i = 0; i < s.length; i++) h = hash(h, s.charCodeAt(i))\n  return h\n}\n","import {Term, TermSet, Rule, cmpSet, Conflicts, union} from \"./grammar\"\nimport {hash, hashString} from \"./hash\"\nimport {GenError} from \"./error\"\n\nexport class Pos {\n  hash: number = 0\n\n  constructor(readonly rule: Rule,\n              readonly pos: number,\n              // NOTE `ahead` and `ambigAhead` aren't mutated anymore after `finish()` has been called\n              readonly ahead: Term[],\n              public ambigAhead: readonly string[],\n              readonly skipAhead: Term,\n              readonly via: Pos | null) {}\n\n  finish() {\n    let h = hash(hash(this.rule.id, this.pos), this.skipAhead.hash)\n    for (let a of this.ahead) h = hash(h, a.hash)\n    for (let group of this.ambigAhead) h = hashString(h, group)\n    this.hash = h\n    return this\n  }\n\n  get next() {\n    return this.pos < this.rule.parts.length ? this.rule.parts[this.pos] : null\n  }\n\n  advance() {\n    return new Pos(this.rule, this.pos + 1, this.ahead, this.ambigAhead, this.skipAhead, this.via).finish()\n  }\n\n  get skip() {\n    return this.pos == this.rule.parts.length ? this.skipAhead : this.rule.skip\n  }\n\n  cmp(pos: Pos) {\n    return this.rule.cmp(pos.rule) || this.pos - pos.pos || this.skipAhead.hash - pos.skipAhead.hash ||\n      cmpSet(this.ahead, pos.ahead, (a, b) => a.cmp(b)) || cmpSet(this.ambigAhead, pos.ambigAhead, cmpStr)\n  }\n\n  eqSimple(pos: Pos) {\n    return pos.rule == this.rule && pos.pos == this.pos\n  }\n\n  toString() {\n    let parts = this.rule.parts.map(t => t.name)\n    parts.splice(this.pos, 0, \"·\")\n    return `${this.rule.name} -> ${parts.join(\" \")}`\n  }\n\n  eq(other: Pos) {\n    return this == other ||\n      this.hash == other.hash && this.rule == other.rule && this.pos == other.pos && this.skipAhead == other.skipAhead &&\n      sameSet(this.ahead, other.ahead) &&\n      sameSet(this.ambigAhead, other.ambigAhead)\n  }\n\n  trail(maxLen: number = 60) {\n    let result = []\n    for (let pos: Pos | null = this; pos; pos = pos.via) {\n      for (let i = pos.pos - 1; i >= 0; i--) result.push(pos.rule.parts[i])\n    }\n    let value = result.reverse().join(\" \")\n    if (value.length > maxLen) value = value.slice(value.length - maxLen).replace(/.*? /, \"… \")\n    return value\n  }\n\n  conflicts(pos = this.pos) {\n    let result = this.rule.conflicts[pos]\n    if (pos == this.rule.parts.length && this.ambigAhead.length) result = result.join(new Conflicts(0, this.ambigAhead))\n    return result\n  }\n\n  static addOrigins(group: readonly Pos[], context: readonly Pos[]) {\n    let result = group.slice()\n    for (let i = 0; i < result.length; i++) {\n      let next = result[i]\n      if (next.pos == 0) for (let pos of context) {\n        if (pos.next == next.rule.name && !result.includes(pos)) result.push(pos)\n      }\n    }\n    return result\n  }\n}\n\nfunction conflictsAt(group: readonly Pos[]) {\n  let result = Conflicts.none\n  for (let pos of group) result = result.join(pos.conflicts())\n  return result\n}\n\n// Applies automatic action precedence based on repeat productions.\n// These are left-associative, so reducing the `R -> R R` rule has\n// higher precedence.\nfunction compareRepeatPrec(a: readonly Pos[], b: readonly Pos[]) {\n  for (let pos of a) if (pos.rule.name.repeated) {\n    for (let posB of b) if (posB.rule.name == pos.rule.name) {\n      if (pos.rule.isRepeatWrap && pos.pos == 2) return 1\n      if (posB.rule.isRepeatWrap && posB.pos == 2) return -1\n    }\n  }\n  return 0\n}\n\nfunction cmpStr(a: string, b: string) {\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\nfunction termsAhead(rule: Rule, pos: number, after: readonly Term[], first: {[name: string]: Term[]}): Term[] {\n  let found: Term[] = []\n  for (let i = pos + 1; i < rule.parts.length; i++) {\n    let next = rule.parts[i], cont = false\n    if (next.terminal) {\n      addTo(next, found)\n    } else for (let term of first[next.name]) {\n      if (term == null) cont = true\n      else addTo(term, found)\n    }\n    if (!cont) return found\n  }\n  for (let a of after) addTo(a, found)\n  return found\n}\n\nfunction eqSet<T extends {eq(other: T): boolean}>(a: readonly T[], b: readonly T[]): boolean {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (!a[i].eq(b[i])) return false\n  return true\n}\n\nfunction sameSet<T>(a: readonly T[], b: readonly T[]) {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i]) return false\n  return true\n}\n\nexport class Shift {\n  constructor(readonly term: Term, readonly target: State) {}\n\n  eq(other: Shift | Reduce): boolean { return other instanceof Shift && this.term == other.term && other.target.id == this.target.id }\n\n  cmp(other: Shift | Reduce): number { return other instanceof Reduce ? -1 : this.term.id - other.term.id || this.target.id - other.target.id }\n\n  toString() { return \"s\" + this.target.id }\n\n  map(mapping: readonly number[], states: readonly State[]) {\n    let mapped = states[mapping[this.target.id]]\n    return mapped == this.target ? this : new Shift(this.term, mapped)\n  }\n}\n\nexport class Reduce {\n  constructor(readonly term: Term, readonly rule: Rule) {}\n\n  eq(other: Shift | Reduce): boolean {\n    return other instanceof Reduce && this.term == other.term && other.rule.sameReduce(this.rule)\n  }\n\n  cmp(other: Shift | Reduce): number {\n    return other instanceof Shift ? 1 : this.term.id - other.term.id || this.rule.name.id - other.rule.name.id ||\n      this.rule.parts.length - other.rule.parts.length\n  }\n\n  toString() { return `${this.rule.name.name}(${this.rule.parts.length})` }\n\n  map() { return this }\n}\n\nfunction hashPositions(set: readonly Pos[]) {\n  let h = 5381\n  for (let pos of set) h = hash(h, pos.hash)\n  return h\n}\n\nexport class State {\n  actions: (Shift | Reduce)[] = []\n  actionPositions: (readonly Pos[])[] = []\n  goto: Shift[] = []\n  tokenGroup: number = -1\n  defaultReduce: Rule | null = null\n  nested = -1\n\n  constructor(public id: number,\n              public set: readonly Pos[],\n              public flags = 0,\n              readonly skip: Term,\n              readonly hash = hashPositions(set),\n              readonly startRule: Term | null = null) {}\n\n  toString() {\n    let actions = this.actions.map(t => t.term + \"=\" + t).join(\",\") +\n      (this.goto.length ? \" | \" + this.goto.map(g => g.term + \"=\" + g).join(\",\") : \"\")\n    return this.id + \": \" + this.set.filter(p => p.pos > 0).join() +\n      (this.defaultReduce ? `\\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`\n       : actions.length ? \"\\n  \" + actions : \"\")\n  }\n\n  addActionInner(value: Shift | Reduce, positions: readonly Pos[]): Shift | Reduce | null {\n    check: for (let i = 0; i < this.actions.length; i++) {\n      let action = this.actions[i]\n      if (action.term == value.term) {\n        if (action.eq(value)) return null\n        let fullPos = Pos.addOrigins(positions, this.set), actionFullPos = Pos.addOrigins(this.actionPositions[i], this.set)\n        let conflicts = conflictsAt(fullPos), actionConflicts = conflictsAt(actionFullPos)\n        let diff = compareRepeatPrec(fullPos, actionFullPos) || conflicts.precedence - actionConflicts.precedence\n        if (diff > 0) { // Drop the existing action\n          this.actions.splice(i, 1)\n          this.actionPositions.splice(i, 1)\n          i--\n          continue check\n        } else if (diff < 0) { // Drop this one\n          return null\n        } else if (conflicts.ambigGroups.some(g => actionConflicts.ambigGroups.includes(g))) { // Explicitly allowed ambiguity\n          continue check\n        } else { // Not resolved\n          return action\n        }\n      }\n    }\n    this.actions.push(value)\n    this.actionPositions.push(positions)\n    return null\n  }\n\n  addAction(value: Shift | Reduce, positions: readonly Pos[], conflicts: Conflict[]) {\n    let conflict = this.addActionInner(value, positions)\n    if (conflict) {\n      let conflictPos = this.actionPositions[this.actions.indexOf(conflict)][0]\n      let rules = [positions[0].rule.name, conflictPos.rule.name]\n      if (conflicts.some(c => c.rules.some(r => rules.includes(r)))) return\n      let error\n      if (conflict instanceof Shift)\n        error = `shift/reduce conflict between\\n  ${conflictPos}\\nand\\n  ${positions[0].rule}`\n      else\n        error = `reduce/reduce conflict between\\n  ${conflictPos.rule}\\nand\\n  ${positions[0].rule}`\n      error += `\\nWith input:\\n  ${positions[0].trail(70)} · ${value.term} …`\n      error += findConflictOrigin(conflictPos, positions[0])\n      conflicts.push(new Conflict(error, rules))\n    }\n  }\n\n  getGoto(term: Term) {\n    return this.goto.find(a => a.term == term)\n  }\n\n  hasSet(set: readonly Pos[]) {\n    return eqSet(this.set, set)\n  }\n\n  finish() {\n    if (this.actions.length) {\n      let first = this.actions[0]\n      if (first instanceof Reduce) {\n        let {rule} = first\n        if (this.actions.every(a => a instanceof Reduce && a.rule.sameReduce(rule)))\n          this.defaultReduce = rule\n      }\n    }\n    this.actions.sort((a, b) => a.cmp(b))\n    this.goto.sort((a, b) => a.cmp(b))\n  }\n\n  eq(other: State) {\n    let dThis = this.defaultReduce, dOther = other.defaultReduce\n    if (dThis || dOther)\n      return dThis && dOther ? dThis.sameReduce(dOther) : false\n    return this.skip == other.skip &&\n      this.tokenGroup == other.tokenGroup &&\n      eqSet(this.actions, other.actions) &&\n      eqSet(this.goto, other.goto)\n  }\n}\n\nfunction closure(set: readonly Pos[], first: {[name: string]: Term[]}) {\n  let added: Pos[] = [], redo: Pos[] = []\n  function addFor(name: Term, ahead: readonly Term[], ambigAhead: readonly string[], skipAhead: Term, via: Pos) {\n    for (let rule of name.rules) {\n      let add = added.find(a => a.rule == rule)\n      if (!add) {\n        let existing = set.find(p => p.pos == 0 && p.rule == rule)\n        add = existing ? new Pos(rule, 0, existing.ahead.slice(), existing.ambigAhead, existing.skipAhead, existing.via)\n          : new Pos(rule, 0, [], none, skipAhead, via)\n        added.push(add)\n      }\n      if (add.skipAhead != skipAhead)\n        throw new GenError(\"Inconsistent skip sets after \" + via.trail())\n      add.ambigAhead = union(add.ambigAhead, ambigAhead)\n      for (let term of ahead) if (!add.ahead.includes(term)) {\n        add.ahead.push(term)\n        if (add.rule.parts.length && !add.rule.parts[0].terminal) addTo(add, redo)\n      }\n    }\n  }\n\n  for (let pos of set) {\n    let next = pos.next\n    if (next && !next.terminal)\n      addFor(next, termsAhead(pos.rule, pos.pos, pos.ahead, first),\n             pos.conflicts(pos.pos + 1).ambigGroups, pos.pos == pos.rule.parts.length - 1 ? pos.skipAhead : pos.rule.skip,\n             pos)\n  }\n  while (redo.length) {\n    let add = redo.pop()!\n    addFor(add.rule.parts[0], termsAhead(add.rule, 0, add.ahead, first),\n           union(add.rule.conflicts[1].ambigGroups, add.rule.parts.length == 1 ? add.ambigAhead : none),\n           add.skipAhead, add)\n  }\n\n  let result = set.slice()\n  for (let add of added) {\n    add.ahead.sort((a, b) => a.hash - b.hash)\n    add.finish()\n    let origIndex = set.findIndex(p => p.pos == 0 && p.rule == add.rule)\n    if (origIndex > -1) result[origIndex] = add\n    else result.push(add)\n  }\n  return result.sort((a, b) => a.cmp(b))\n}\n\nfunction addTo<T>(value: T, array: T[]) {\n  if (!array.includes(value)) array.push(value)\n}\n\nexport function computeFirstSets(terms: TermSet) {\n  let table: {[term: string]: Term[]} = Object.create(null)\n  for (let t of terms.terms) if (!t.terminal) table[t.name] = []\n  for (;;) {\n    let change = false\n    for (let nt of terms.terms) if (!nt.terminal) for (let rule of nt.rules) {\n      let set = table[nt.name]\n      let found = false, startLen = set.length\n      for (let part of rule.parts) {\n        found = true\n        if (part.terminal) {\n          addTo(part, set)\n        } else {\n          for (let t of table[part.name]) {\n            if (t == null) found = false\n            else addTo(t, set)\n          }\n        }\n        if (found) break\n      }\n      if (!found) addTo(null, set)\n      if (set.length > startLen) change = true\n    }\n    if (!change) return table\n  }\n}\n\nclass Core {\n  constructor(readonly set: readonly Pos[], readonly state: State) {}\n}\n\nclass Conflict {\n  constructor(readonly error: string, readonly rules: readonly Term[]) {}\n}\n\nfunction findConflictOrigin(a: Pos, b: Pos) {\n  if (a.eqSimple(b)) return \"\"\n  function via(root: Pos, start: Pos) {\n    let hist = []\n    for (let p = start.via!; !p.eqSimple(root); p = p.via!) hist.push(p)\n    if (!hist.length) return \"\"\n    hist.unshift(start)\n    return hist.reverse().map((p, i) => \"\\n\" + \"  \".repeat(i + 1) + (p == start ? \"\" : \"via \") + p).join(\"\")\n  }\n\n  for (let p: Pos | null = a; p; p = p.via) for (let p2: Pos | null = b; p2; p2 = p2.via) {\n    if (p.eqSimple(p2)) return \"\\nShared origin: \" + p + via(p, a) + via(p, b)\n  }\n  return \"\"\n}\n\n// Builds a full LR(1) automaton\nexport function buildFullAutomaton(terms: TermSet, startTerms: Term[], first: {[name: string]: Term[]}) {\n  let states: State[] = []\n  let cores: {[hash: number]: Core[]} = {}\n  function getState(core: readonly Pos[], top?: Term) {\n    if (core.length == 0) return null\n    let coreHash = hashPositions(core), byHash = cores[coreHash]\n    let skip: Term | undefined\n    for (let pos of core) {\n      if (!skip) skip = pos.skip\n      else if (skip != pos.skip) throw new GenError(\"Inconsistent skip sets after \" + pos.trail())\n    }\n    if (byHash) for (let known of byHash) if (eqSet(core, known.set)) {\n      if (known.state.skip != skip) throw new GenError(\"Inconsistent skip sets after \" + known.set[0].trail())\n      return known.state\n    }\n\n    let set = closure(core, first)\n    let hash = hashPositions(set), found\n    if (!top) for (let state of states) if (state.hash == hash && state.hasSet(set)) found = state\n    if (!found) {\n      found = new State(states.length, set, 0, skip!, hash, top)\n      states.push(found)\n    }\n    ;(cores[coreHash] || (cores[coreHash] = [])).push(new Core(core, found))\n    return found\n  }\n\n  for (const startTerm of startTerms) {\n    const startSkip = startTerm.rules.length ? startTerm.rules[0].skip : terms.names[\"%noskip\"]!\n    getState(startTerm.rules.map(rule => new Pos(rule, 0, [terms.eof], none, startSkip, null).finish()), startTerm)\n  }\n\n  let conflicts: Conflict[] = []\n\n  for (let filled = 0; filled < states.length; filled++) {\n    let state = states[filled]\n    let byTerm: Term[] = [], byTermPos: Pos[][] = [], atEnd: Pos[] = []\n    for (let pos of state.set) {\n      if (pos.pos == pos.rule.parts.length) {\n        if (!pos.rule.name.top) atEnd.push(pos)\n      } else {\n        let next = pos.rule.parts[pos.pos]\n        let index = byTerm.indexOf(next)\n        if (index < 0) {\n          byTerm.push(next)\n          byTermPos.push([pos])\n        } else {\n          byTermPos[index].push(pos)\n        }\n      }\n    }\n    for (let i = 0; i < byTerm.length; i++) {\n      let term = byTerm[i], positions = byTermPos[i].map(p => p.advance())\n      if (term.terminal) {\n        let set = applyCut(positions)\n        let next = getState(set)\n        if (next) state.addAction(new Shift(term, next), byTermPos[i], conflicts)\n      } else {\n        let goto = getState(positions)\n        if (goto) state.goto.push(new Shift(term, goto))\n      }\n    }\n\n    let replaced = false\n    for (let pos of atEnd) for (let ahead of pos.ahead) {\n      let count = state.actions.length\n      state.addAction(new Reduce(ahead, pos.rule), [pos], conflicts)\n      if (state.actions.length == count) replaced = true\n    }\n\n    // If some actions were replaced by others, double-check whether\n    // goto entries are now superfluous (for example, in an operator\n    // precedence-related state that has a shift for `*` but only a\n    // reduce for `+`, we don't need a goto entry for rules that start\n    // with `+`)\n    if (replaced) for (let i = 0; i < state.goto.length; i++) {\n      let start = first[state.goto[i].term.name]\n      if (!start.some(term => state.actions.some(a => a.term == term && (a instanceof Shift))))\n        state.goto.splice(i--, 1)\n    }\n  }\n\n  if (conflicts.length) throw new GenError(conflicts.map(c => c.error).join(\"\\n\\n\"))\n\n  // Resolve alwaysReduce and sort actions\n  for (let state of states) state.finish()\n  return states\n}\n\nfunction applyCut(set: readonly Pos[]): readonly Pos[] {\n  let found: null | Pos[] = null, cut = 1\n  for (let pos of set) {\n    let value = pos.rule.conflicts[pos.pos - 1].cut\n    if (value < cut) continue\n    if (!found || value > cut) {\n      cut = value\n      found = []\n    }\n    found.push(pos)\n  }\n  return found || set\n}\n\nfunction canMergeInner(a: State, b: State, mapping: readonly number[]) {\n  for (let goto of a.goto) for (let other of b.goto) {\n    if (goto.term == other.term && mapping[goto.target.id] != mapping[other.target.id]) return false\n  }\n  actions: for (let action of a.actions) {\n    let conflict = false\n    for (let other of b.actions) if (other.term == action.term) {\n      if (action instanceof Shift\n          ? other instanceof Shift && mapping[action.target.id] == mapping[other.target.id]\n          : other.eq(action)) continue actions\n      conflict = true\n    }\n    if (conflict) return false\n  }\n  return true\n}\n\nfunction canMerge(a: State, b: State, mapping: readonly number[]) {\n  return canMergeInner(a, b, mapping) && canMergeInner(b, a, mapping)\n}\n\nfunction mergeStates(states: readonly State[], mapping: readonly number[]) {\n  let newStates = []\n  for (let state of states) {\n    let newID = mapping[state.id]\n    if (!newStates[newID]) {\n      newStates[newID] = new State(newID, state.set, 0, state.skip, state.hash, state.startRule)\n      newStates[newID].tokenGroup = state.tokenGroup\n      newStates[newID].defaultReduce = state.defaultReduce\n    }\n  }\n  for (let state of states) {\n    let newID = mapping[state.id], target = newStates[newID]\n    target.flags |= state.flags\n    for (let i = 0; i < state.actions.length; i++) {\n      let action = state.actions[i].map(mapping, newStates)\n      if (!target.actions.some(a => a.eq(action))) {\n        target.actions.push(action)\n        target.actionPositions.push(state.actionPositions[i])\n      }\n    }\n    for (let goto of state.goto) {\n      let mapped = goto.map(mapping, newStates)\n      if (!target.goto.some(g => g.eq(mapped))) target.goto.push(mapped)\n    }\n  }\n  return newStates\n}\n\nclass Group {\n  members: number[]\n  constructor(readonly origin: number, member: number) { this.members = [member] }\n}\n\nfunction samePosSet(a: readonly Pos[], b: readonly Pos[]) {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (!a[i].eqSimple(b[i])) return false\n  return true\n}\n\n// Collapse an LR(1) automaton to an LALR-like automaton\nfunction collapseAutomaton(states: readonly State[]): readonly State[] {\n  let mapping: number[] = [], groups: Group[] = []\n  assignGroups: for (let i = 0; i < states.length; i++) {\n    let state = states[i]\n    if (!state.startRule) for (let j = 0; j < groups.length; j++) {\n      let group = groups[j], other = states[group.members[0]]\n      if (state.tokenGroup == other.tokenGroup &&\n          state.skip == other.skip &&\n          !other.startRule &&\n          samePosSet(state.set, other.set)) {\n        group.members.push(i)\n        mapping.push(j)\n        continue assignGroups\n      }\n    }\n    mapping.push(groups.length)\n    groups.push(new Group(groups.length, i))\n  }\n\n  function spill(groupIndex: number, index: number) {\n    let group = groups[groupIndex], state = states[group.members[index]]\n    let pop = group.members.pop()!\n    if (index != group.members.length) group.members[index] = pop\n    for (let i = groupIndex + 1; i < groups.length; i++) {\n      mapping[state.id] = i\n      if (groups[i].origin == group.origin &&\n          groups[i].members.every(id => canMerge(state, states[id], mapping))) {\n        groups[i].members.push(state.id)\n        return\n      }\n    }\n    mapping[state.id] = groups.length\n    groups.push(new Group(group.origin, state.id))\n  }\n\n  for (;;) {\n    let conflicts = false\n    for (let g = 0, startLen = groups.length; g < startLen; g++) {\n      let group = groups[g]\n      for (let i = 0; i < group.members.length - 1; i++) {\n        for (let j = i + 1; j < group.members.length; j++) {\n          let idA = group.members[i], idB = group.members[j]\n          if (!canMerge(states[idA], states[idB], mapping)) {\n            conflicts = true\n            spill(g, j--)\n          }\n        }\n      }\n    }\n    if (!conflicts) return mergeStates(states, mapping)\n  }\n}\n\nfunction mergeIdentical(states: readonly State[]): readonly State[] {\n  for (;;) {\n    let mapping: number[] = [], didMerge = false\n    let newStates: State[] = []\n    // Find states that either have the same alwaysReduce or the same\n    // actions, and merge them.\n    for (let i = 0; i < states.length; i++) {\n      let state = states[i]\n      let match = newStates.findIndex(s => state.eq(s))\n      if (match < 0) {\n        mapping[i] = newStates.length\n        newStates.push(state)\n      } else {\n        mapping[i] = match\n        didMerge = true\n        let other = newStates[match], add: Pos[] | null = null\n        for (let pos of state.set) if (!other.set.some(p => p.eqSimple(pos))) (add || (add = [])).push(pos)\n        if (add) other.set = add.concat(other.set).sort((a, b) => a.cmp(b))\n      }\n    }\n    if (!didMerge) return states\n    // Make sure actions point at merged state objects\n    for (let state of newStates) if (!state.defaultReduce) {\n      state.actions = state.actions.map(a => a.map(mapping, newStates))\n      state.goto = state.goto.map(a => a.map(mapping, newStates))\n    }\n    // Renumber ids\n    for (let i = 0; i < newStates.length; i++) newStates[i].id = i\n    states = newStates\n  }\n}\n\nconst none: readonly any[] = []\n\nexport function finishAutomaton(full: readonly State[]) {\n  return mergeIdentical(collapseAutomaton(full))\n}\n","// Encode numbers as groups of printable ascii characters\n//\n// - 0xffff, which is often used as placeholder, is encoded as \"~\"\n//\n// - The characters from \" \" (32) to \"}\" (125), excluding '\"' and\n//   \"\\\\\", indicate values from 0 to 92\n//\n// - The first bit in a 'digit' is used to indicate whether this is\n//   the end of a number.\n//\n// - That leaves 46 other values, which are actually significant.\n//\n// - The digits in a number are ordered from high to low significance.\n\nimport {Encode} from \"lezer/dist/constants\"\n\nfunction digitToChar(digit: number) {\n  let ch = digit + Encode.Start\n  if (ch >= Encode.Gap1) ch++\n  if (ch >= Encode.Gap2) ch++\n  return String.fromCharCode(ch)\n}\n\nexport function encode(value: number, max = 0xffff) {\n  if (value > max) throw new Error(\"Trying to encode a number that's too big: \" + value)\n  if (value == Encode.BigVal) return String.fromCharCode(Encode.BigValCode)\n  let result = \"\"\n  for (let first = Encode.Base;; first = 0) {\n    let low = value % Encode.Base, rest = value - low\n    result = digitToChar(low + first) + result\n    if (rest == 0) break\n    value = rest / Encode.Base\n  }\n  return result\n}\n\nexport function encodeArray(values: {length: number, readonly [i: number]: number}, max = 0xffff) {\n  let result = '\"' + encode(values.length, 0xffffffff)\n  for (let i = 0; i < values.length; i++) result += encode(values[i], max)\n  result += '\"'\n  return result\n}\n","import {GrammarDeclaration, RuleDeclaration, TokenDeclaration, ExternalTokenDeclaration,\n        ExternalSpecializeDeclaration,\n        Expression, Identifier, LiteralExpression, NameExpression, SequenceExpression,\n        ChoiceExpression, RepeatExpression, SetExpression, AnyExpression, ConflictMarker,\n        InlineRuleExpression, SpecializeExpression, Prop, PropPart,\n        exprsEq, exprEq} from \"./node\"\nimport {Term, TermSet, Rule, Conflicts, Props, hasProps} from \"./grammar\"\nimport {State, MAX_CHAR, Conflict} from \"./token\"\nimport {Input} from \"./parse\"\nimport {computeFirstSets, buildFullAutomaton, finishAutomaton, State as LRState, Shift, Reduce, Pos} from \"./automaton\"\nimport {encodeArray} from \"./encode\"\nimport {GenError} from \"./error\"\nimport {Parser, ExternalTokenizer, NestedParser, Stack, NodeProp, ContextTracker} from \"lezer\"\nimport {Action, Specialize, StateFlag, Seq, ParseState, File} from \"lezer/dist/constants\"\n\nconst none: readonly any[] = []\n\nconst verbose = (typeof process != \"undefined\" && process.env.LOG) || \"\"\n\nclass Parts {\n  constructor(readonly terms: readonly Term[],\n              readonly conflicts: null | readonly Conflicts[]) {}\n\n  concat(other: Parts) {\n    if (this == Parts.none) return other\n    if (other == Parts.none) return this\n    let conflicts: null | Conflicts[] = null\n    if (this.conflicts || other.conflicts) {\n      conflicts = this.conflicts ? this.conflicts.slice() : this.ensureConflicts() as Conflicts[]\n      let otherConflicts = other.ensureConflicts()\n      conflicts[conflicts.length - 1] = conflicts[conflicts.length - 1].join(otherConflicts[0])\n      for (let i = 1; i < otherConflicts.length; i++) conflicts.push(otherConflicts[i])\n    }\n    return new Parts(this.terms.concat(other.terms), conflicts)\n  }\n\n  withConflicts(pos: number, conflicts: Conflicts) {\n    if (conflicts == Conflicts.none) return this\n    let array = this.conflicts ? this.conflicts.slice() : this.ensureConflicts() as Conflicts[]\n    array[pos] = array[pos].join(conflicts)\n    return new Parts(this.terms, array)\n  }\n\n  ensureConflicts() {\n    if (this.conflicts) return this.conflicts\n    let empty = []\n    for (let i = 0; i <= this.terms.length; i++) empty.push(Conflicts.none)\n    return empty\n  }\n\n  static none = new Parts(none, null)\n}\n\nfunction p(...terms: Term[]) { return new Parts(terms, null) }\n\nclass BuiltRule {\n  constructor(readonly id: string,\n              readonly args: readonly Expression[],\n              readonly term: Term) {}\n\n  matches(expr: NameExpression) {\n    return this.id == expr.id.name && exprsEq(expr.args, this.args)\n  }\n\n  matchesRepeat(expr: RepeatExpression) {\n    return this.id == \"+\" && exprEq(expr.expr, this.args[0])\n  }\n}\n\nexport type BuildOptions = {\n  /// The name of the grammar file\n  fileName?: string,\n  /// A function that should be called with warnings. The default is\n  /// to call `console.warn`.\n  warn?: (message: string) => void,\n  /// Whether to include term names in the output file. Defaults to\n  /// false.\n  includeNames?: boolean,\n  /// Determines the module system used by the output file. Can be\n  /// either `\"cjs\"` (CommonJS) or `\"es\"` (ES2015 module), defaults to\n  /// `\"es\"`.\n  moduleStyle?: string,\n  /// The name of the export that holds the parser in the output file.\n  /// Defaults to `\"parser\"`.\n  exportName?: string,\n  /// When calling `buildParser`, this can be used to provide\n  /// placeholders for external tokenizers.\n  externalTokenizer?: (name: string, terms: {[name: string]: number}) => ExternalTokenizer\n  /// Provide placeholders for external specializers when using\n  /// `buildParser`.\n  externalSpecializer?: (name: string, terms: {[name: string]: number}) => (value: string, stack: Stack) => number\n  /// Only relevant when using `buildParser`. Provides placeholders\n  /// for nested grammars.\n  nestedParser?: (name: string, terms: {[name: string]: number}) => NestedParser | Parser\n  /// If given, will be used to initialize external props in the parser\n  /// returned by `buildParser`.\n  externalProp?: (name: string) => NodeProp<any>\n  /// If given, will be used as context tracker in a parser built with\n  /// `buildParser`.\n  contextTracker?: ContextTracker<any>\n}\n\ntype SkipInfo = {skip: readonly Term[], rule: Term | null, startTokens: readonly Term[], id: number}\n\nclass Builder {\n  ast: GrammarDeclaration\n  input: Input\n  terms = new TermSet\n  tokens: TokenSet\n  externalTokens: ExternalTokenSet[]\n  externalSpecializers: ExternalSpecializer[]\n  nestedParsers: NestedParserSpec[] = []\n  specialized: {[name: string]: {value: string, name: string | null, term: Term, type: string, dialect: number | null}[]}\n    = Object.create(null)\n  tokenOrigins: {[name: string]: {spec?: Term, external?: ExternalTokenSet | ExternalSpecializer}} = Object.create(null)\n  rules: Rule[] = []\n  built: BuiltRule[] = []\n  ruleNames: {[name: string]: Identifier | null} = Object.create(null)\n  namespaces: {[name: string]: Namespace} = Object.create(null)\n  namedTerms: {[name: string]: Term} = Object.create(null)\n  termTable: {[name: string]: number} = Object.create(null)\n  knownProps: {[name: string]: {prop: NodeProp<any>, source: {name: string, from: string | null}}} = Object.create(null)\n  dialects: readonly string[]\n  dynamicRulePrecedences: {rule: Term, prec: number}[] = []\n  definedGroups: {name: Term, group: string, rule: RuleDeclaration}[] = []\n\n  astRules: {skip: Term, rule: RuleDeclaration}[] = []\n  currentSkip: Term[] = []\n  skipRules: Term[]\n\n  constructor(text: string, readonly options: BuildOptions) {\n    this.input = new Input(text, options.fileName)\n    this.ast = this.input.parse()\n\n    let NP: {[key: string]: any} = NodeProp\n    for (let prop in NP) {\n      if (NP[prop] instanceof NodeProp) this.knownProps[prop] = {prop: NP[prop], source: {name: prop, from: null}}\n    }\n    for (let prop of this.ast.externalProps) {\n      this.knownProps[prop.id.name] = {\n        prop: this.options.externalProp ? this.options.externalProp(prop.id.name) : NodeProp.string(),\n        source: {name: prop.externalID.name, from: prop.source}\n      }\n    }\n\n    this.dialects = this.ast.dialects.map(d => d.name)\n\n    this.tokens = new TokenSet(this, this.ast.tokens)\n    this.externalTokens = this.ast.externalTokens.map(ext => new ExternalTokenSet(this, ext))\n    this.externalSpecializers = this.ast.externalSpecializers.map(decl => new ExternalSpecializer(this, decl))\n\n    this.defineNamespace(\"nest\", new NestNamespace)\n\n    for (let grammar of this.ast.grammars) {\n      if (this.ast.grammars.some(g => g != grammar && g.id.name == grammar.id.name))\n        this.raise(`Duplicate external grammar name '${grammar.id.name}'`, grammar.id.start)\n    }\n\n    let noSkip = this.newName(\"%noskip\", true)\n    this.defineRule(noSkip, [])\n\n    let mainSkip = this.ast.mainSkip ? this.newName(\"%mainskip\", true) : noSkip\n    let scopedSkip: Term[] = []\n    for (let rule of this.ast.rules) this.astRules.push({skip: mainSkip, rule})\n    for (let scoped of this.ast.scopedSkip) {\n      let skip = noSkip, found = this.ast.scopedSkip.findIndex((sc, i) => i < scopedSkip.length && exprEq(sc.expr, scoped.expr))\n      if (found > -1) skip = scopedSkip[found]\n      else if (this.ast.mainSkip && exprEq(scoped.expr, this.ast.mainSkip)) skip = mainSkip\n      else if (!isEmpty(scoped.expr)) skip = this.newName(\"%skip\", true)\n      scopedSkip.push(skip)\n      for (let rule of scoped.rules) this.astRules.push({skip, rule})\n    }\n\n    for (let {rule} of this.astRules) {\n      this.unique(rule.id)\n      if (this.namespaces[rule.id.name])\n        this.raise(`Rule name '${rule.id.name}' conflicts with a defined namespace`, rule.id.start)\n    }\n\n    this.currentSkip.push(noSkip)\n    this.skipRules = mainSkip == noSkip ? [mainSkip] : [noSkip, mainSkip]\n    if (mainSkip != noSkip)\n      this.defineRule(mainSkip, this.normalizeExpr(this.ast.mainSkip!))\n    for (let i = 0; i < this.ast.scopedSkip.length; i++) {\n      let skip = scopedSkip[i]\n      if (!this.skipRules.includes(skip)) {\n        this.skipRules.push(skip)\n        if (skip != noSkip)\n          this.defineRule(skip, this.normalizeExpr(this.ast.scopedSkip[i].expr))\n      }\n    }\n    this.currentSkip.pop()\n\n    for (const top of this.ast.topRules) {\n      this.unique(top.id)\n      this.used(top.id.name)\n      this.currentSkip.push(mainSkip)\n      let {name, props} = this.nodeInfo(top.props, \"t\", top.id.name, none, none, top.expr)\n      let term = this.terms.makeTop(name, props)\n      this.namedTerms[name!] = term\n      this.defineRule(term, this.normalizeExpr(top.expr))\n      this.currentSkip.pop()\n    }\n\n    for (let ext of this.externalSpecializers) ext.finish()\n\n    for (let {skip, rule} of this.astRules) {\n      if (this.ruleNames[rule.id.name] && isExported(rule) && !rule.params.length) {\n        this.buildRule(rule, [], skip, false)\n        if (rule.expr instanceof SequenceExpression && rule.expr.exprs.length == 0)\n          this.used(rule.id.name)\n      }\n    }\n\n    for (let name in this.ruleNames) {\n      let value = this.ruleNames[name]\n      if (value) this.warn(`Unused rule '${value.name}'`, value.start)\n    }\n\n    this.tokens.takePrecedences()\n    this.tokens.takeConflicts()\n\n    for (let {name, group, rule} of this.definedGroups) this.defineGroup(name, group, rule)\n    this.checkGroups()\n  }\n\n  unique(id: Identifier) {\n    if (id.name in this.ruleNames)\n      this.raise(`Duplicate definition of rule '${id.name}'`, id.start)\n    this.ruleNames[id.name] = id\n  }\n\n  used(name: string) {\n    this.ruleNames[name] = null\n  }\n\n  defineNamespace(name: string, value: Namespace, pos: number = 0) {\n    if (this.namespaces[name]) this.raise(`Duplicate definition of namespace '${name}'`, pos)\n    this.namespaces[name] = value\n  }\n\n  newName(base: string, nodeName: string | null | true = null, props: Props = {}): Term {\n    for (let i = nodeName ? 0 : 1;; i++) {\n      let name = i ? `${base}-${i}` : base\n      if (!this.terms.names[name])\n        return this.terms.makeNonTerminal(name, nodeName === true ? null : nodeName, props)\n    }\n  }\n\n  prepareParser() {\n    let rules = simplifyRules(this.rules, [...this.skipRules,\n                                           ...this.nestedParsers.map(g => g.placeholder),\n                                           ...this.terms.tops])\n    let {nodeTypes, names: termNames, minRepeatTerm, maxTerm} = this.terms.finish(rules)\n    for (let prop in this.namedTerms) this.termTable[prop] = this.namedTerms[prop].id\n\n    if (/\\bgrammar\\b/.test(verbose)) console.log(rules.join(\"\\n\"))\n\n    let startTerms = this.terms.tops.slice()\n    let first = computeFirstSets(this.terms)\n    let skipInfo: readonly SkipInfo[] = this.skipRules.map((name, id) => {\n      let skip = [], startTokens: Term[] = [], rules: Rule[] = []\n      for (let rule of name.rules) {\n        if (!rule.parts.length) continue\n        let start = rule.parts[0]\n        for (let t of start.terminal ? [start] : first[start.name] || [])\n          if (!startTokens.includes(t)) startTokens.push(t)\n        if (start.terminal && rule.parts.length == 1 && !rules.some(r => r != rule && r.parts[0] == start))\n          skip.push(start)\n        else\n          rules.push(rule)\n      }\n      name.rules = rules\n      if (rules.length) startTerms.push(name)\n      return {skip, rule: rules.length ? name : null, startTokens, id}\n    })\n    let fullTable = buildFullAutomaton(this.terms, startTerms, first)\n    let {tokenGroups, tokenPrec, tokenData} = this.tokens.buildTokenGroups(fullTable, skipInfo)\n    let table = finishAutomaton(fullTable) as readonly LRState[]\n    let skipState = findSkipStates(table, this.terms.tops)\n\n    this.addNestedParsers(table)\n\n    if (/\\blr\\b/.test(verbose)) console.log(table.join(\"\\n\"))\n\n    let specialized: (ExternalSpecializer | {token: Term, table: {[value: string]: number}})[] = []\n    for (let ext of this.externalSpecializers)\n      specialized.push(ext)\n    for (let name in this.specialized)\n      specialized.push({token: this.terms.names[name], table: buildSpecializeTable(this.specialized[name])})\n\n    let tokStart = (tokenizer: TokenGroup | ExternalTokenDeclaration) => {\n      if (tokenizer instanceof ExternalTokenDeclaration) return tokenizer.start\n      return this.tokens.ast ? this.tokens.ast.start : -1\n    }\n    let tokenizers = (tokenGroups as (TokenGroup | ExternalTokenDeclaration)[])\n      .concat(this.externalTokens.map(e => e.ast)).sort((a, b) => tokStart(a) - tokStart(b))\n\n    let data = new DataBuilder\n    let skipData = skipInfo.map(info => {\n      let actions: number[] = []\n      for (let term of info.skip)\n        actions.push(term.id, 0, Action.StayFlag >> 16)\n      if (info.rule) {\n        let state = table.find(s => s.startRule == info.rule)!\n        for (let action of state.actions as Shift[])\n          actions.push(action.term.id, state.id, Action.GotoFlag >> 16)\n      }\n      actions.push(Seq.End, Seq.Done)\n      return data.storeArray(actions)\n    })\n    let states = new Uint32Array(table.length * ParseState.Size)\n    let forceReductions = this.computeForceReductions(table, skipInfo)\n    let finishCx = new FinishStateContext(tokenizers, data, states, skipData, skipInfo, table, this)\n    for (let s of table) finishCx.finish(s, skipState(s.id), forceReductions[s.id])\n    let dialects: {[name: string]: number} = Object.create(null)\n    for (let i = 0; i < this.dialects.length; i++)\n      dialects[this.dialects[i]] = data.storeArray((this.tokens.byDialect[i] || none).map(t => t.id).concat(Seq.End))\n\n    let dynamicPrecedences = null\n    if (this.dynamicRulePrecedences.length) {\n      dynamicPrecedences = Object.create(null)\n      for (let {rule, prec} of this.dynamicRulePrecedences) dynamicPrecedences[rule.id] = prec\n    }\n\n    let topRules: {[rule: string]: [number, number]} = Object.create(null)\n    for (let term of this.terms.tops)\n      topRules[term.nodeName!] = [table.find(state => state.startRule == term)!.id, term.id]\n\n    let precTable = data.storeArray(tokenPrec.concat(Seq.End))\n    let {nodeProps, skippedTypes} = this.gatherNodeProps(nodeTypes)\n\n    return {\n      states,\n      stateData: data.finish(),\n      goto: computeGotoTable(table),\n      nodeNames: nodeTypes.filter(t => t.id < minRepeatTerm).map(t => t.nodeName).join(\" \"),\n      nodeProps,\n      skippedTypes,\n      maxTerm,\n      repeatNodeCount: nodeTypes.length - minRepeatTerm,\n      tokenizers,\n      tokenData,\n      topRules,\n      dialects,\n      dynamicPrecedences,\n      specialized,\n      tokenPrec: precTable,\n      termNames\n    }\n  }\n\n  getParser() {\n    let {\n      states,\n      stateData,\n      goto,\n      nodeNames,\n      nodeProps: rawNodeProps,\n      skippedTypes,\n      maxTerm,\n      repeatNodeCount,\n      tokenizers: rawTokenizers,\n      tokenData,\n      topRules,\n      dialects,\n      dynamicPrecedences,\n      specialized: rawSpecialized,\n      tokenPrec,\n      termNames\n    } = this.prepareParser()\n\n    let specialized = rawSpecialized.map(v => {\n      if (v instanceof ExternalSpecializer) {\n        let ext = this.options.externalSpecializer!(v.ast.id.name, this.termTable)\n        return {term: v.term!.id, get: (value: string, stack: Stack) => (ext(value, stack) << 1) |\n                (v.ast.type == \"extend\" ? Specialize.Extend : Specialize.Specialize)}\n      } else {\n        return {term: v.token.id, get: (value: string) => v.table[value] || -1}\n      }\n    })\n\n    let tokenizers = rawTokenizers.map(tok => {\n      return tok instanceof ExternalTokenDeclaration\n        ? this.options.externalTokenizer!(tok.id.name, this.termTable)\n        : tok.id\n    })\n\n    return (Parser as any).deserialize({\n      version: File.Version,\n      states,\n      stateData,\n      goto,\n      nodeNames,\n      maxTerm,\n      repeatNodeCount,\n      nodeProps: rawNodeProps.map(({prop, terms}) => [this.knownProps[prop].prop, ...terms]),\n      skippedNodes: skippedTypes,\n      tokenData,\n      tokenizers,\n      context: this.ast.context ? this.options.contextTracker : undefined,\n      topRules,\n      nested: this.nestedParsers.map(spec => {\n        return [spec.name, spec.source ? this.options.nestedParser!(spec.name, this.termTable) : {},\n                spec.end.compile().toArray({}, none), spec.placeholder.id]\n      }),\n      dialects,\n      dynamicPrecedences,\n      specialized,\n      tokenPrec,\n      termNames\n    })\n  }\n\n  getParserFile() {\n    let {\n      states,\n      stateData,\n      goto,\n      nodeNames,\n      nodeProps: rawNodeProps,\n      skippedTypes,\n      maxTerm,\n      repeatNodeCount,\n      tokenizers: rawTokenizers,\n      tokenData,\n      topRules,\n      dialects: rawDialects,\n      dynamicPrecedences,\n      specialized: rawSpecialized,\n      tokenPrec,\n      termNames\n    } = this.prepareParser()\n\n    let mod = this.options.moduleStyle || \"es\"\n\n    let gen = \"// This file was generated by lezer-generator. You probably shouldn't edit it.\\n\", head = gen\n    head += mod == \"cjs\" ? `const {Parser} = require(\"lezer\")\\n`\n      : `import {Parser} from \"lezer\"\\n`\n    let imports: {[source: string]: string[]} = {}, imported: {[spec: string]: string} = Object.create(null)\n    let defined = Object.create(null)\n    let exportName = this.options.exportName || \"parser\"\n    defined.Parser = defined[exportName] = true\n    let getName = (prefix: string) => {\n      for (let i = 0;; i++) {\n        let id = prefix + (i ? \"_\" + i : \"\")\n        if (!defined[id]) return id\n      }\n    }\n\n    let importName = (name: string, source: string, prefix: string) => {\n      let spec = name + \" from \" + source\n      if (imported[spec]) return imported[spec]\n      let src = JSON.stringify(source), varName = name\n      if (name in defined) {\n        varName = getName(prefix)\n        name += `${mod == \"cjs\" ? \":\" : \" as\"} ${varName}`\n      }\n      ;(imports[src] || (imports[src] = [])).push(name)\n      return imported[spec] = varName\n    }\n\n    let tokenizers = rawTokenizers.map(tok => {\n      if (tok instanceof ExternalTokenDeclaration) {\n        let {source, id: {name}} = tok\n        return importName(name, source, \"tok\")\n      } else {\n        return tok.id\n      }\n    })\n\n    let nested = this.nestedParsers.map(spec => {\n      return `[${JSON.stringify(spec.name)}, ${spec.source ? importName(spec.extName, spec.source, spec.name) : \"{}\"},\\\n${encodeArray(spec.end.compile().toArray({}, none))}, ${spec.placeholder.id}]`\n    })\n\n    let context = this.ast.context ? importName(this.ast.context.id.name, this.ast.context.source, \"cx\") : null\n\n    let nodeProps = rawNodeProps.map(({prop, terms}) => {\n      let {source} = this.knownProps[prop]\n      let propID = source.from ? importName(source.name, source.from, \"prop\") :\n        importName(\"NodeProp\", \"lezer\", \"NodeProp\") + \".\" + source.name\n      return `[${propID}, ${terms.map(serializePropValue).join(\",\")}]`\n    })\n\n    function specializationTableString(table: {[name: string]: number}) {\n      return \"{__proto__:null,\" + Object.keys(table).map(key => `${/\\W/.test(key) ? JSON.stringify(key) : key}:${table[key]}`)\n        .join(\", \") + \"}\"\n    }\n\n    let specHead = \"\"\n    let specialized = rawSpecialized.map(v => {\n      if (v instanceof ExternalSpecializer) {\n        let name = importName(v.ast.id.name, v.ast.source, v.ast.id.name)\n        return `{term: ${v.term!.id}, get: (value, stack) => (${name}(value, stack) << 1)${\n          v.ast.type == \"extend\" ? ` | ${Specialize.Extend}` : ''}}`\n      } else {\n        let tableName = getName(\"spec_\" + v.token.name.replace(/\\W/g, \"\"))\n        specHead += `const ${tableName} = ${specializationTableString(v.table)}\\n`\n        return `{term: ${v.token.id}, get: value => ${tableName}[value] || -1}`\n      }\n    })\n\n    for (let source in imports) {\n      if (mod == \"cjs\")\n        head += `const {${imports[source].join(\", \")}} = require(${source})\\n`\n      else\n        head += `import {${imports[source].join(\", \")}} from ${source}\\n`\n    }\n\n    head += specHead\n\n    function serializePropValue(value: any) {\n      return typeof value != \"string\" || /^(true|false|\\d+(\\.\\d+)?|\\.\\d+)$/.test(value) ? value : JSON.stringify(value)\n    }\n\n    let dialects = Object.keys(rawDialects).map(d => `${d}: ${rawDialects[d]}`)\n\n    let parserStr = `Parser.deserialize({\n  version: ${File.Version},\n  states: ${encodeArray(states, 0xffffffff)},\n  stateData: ${encodeArray(stateData)},\n  goto: ${encodeArray(goto)},\n  nodeNames: ${JSON.stringify(nodeNames)},\n  maxTerm: ${maxTerm}${context ? `,\n  context: ${context}` : \"\"}${nodeProps.length ? `,\n  nodeProps: [\n    ${nodeProps.join(\",\\n    \")}\n  ]` : \"\"}${skippedTypes.length ? `,\n  skippedNodes: ${JSON.stringify(skippedTypes)}` : \"\"},\n  repeatNodeCount: ${repeatNodeCount},\n  tokenData: ${encodeArray(tokenData)},\n  tokenizers: [${tokenizers.join(\", \")}],\n  topRules: ${JSON.stringify(topRules)}${nested.length ? `,\n  nested: [${nested.join(\", \")}]` : \"\"}${dialects.length ? `,\n  dialects: {${dialects.join(\", \")}}` : \"\"}${dynamicPrecedences ? `,\n  dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}` : \"\"}${specialized.length ? `,\n  specialized: [${specialized.join(\",\")}]` : \"\"},\n  tokenPrec: ${tokenPrec}${this.options.includeNames ? `,\n  termNames: ${JSON.stringify(termNames)}` : ''}\n})` // FIXME more compact format for term names (omit named nodes, drop quotes)\n\n    let terms: string[] = []\n    for (let name in this.termTable) {\n      let id = name\n      if (KEYWORDS.includes(id)) for (let i = 1;; i++) {\n        id = \"_\".repeat(i) + name\n        if (!(id in this.termTable)) break\n      }\n      terms.push(`${id}${mod == \"cjs\" ? \":\" : \" =\"} ${this.termTable[name]}`)\n    }\n    for (let id = 0; id < this.dialects.length; id++)\n      terms.push(`Dialect_${this.dialects[id]}${mod == \"cjs\" ? \":\" : \" =\"} ${id}`)\n\n    return {\n      parser: head + (mod == \"cjs\" ? `exports.${exportName} = ${parserStr}\\n` : `export const ${exportName} = ${parserStr}\\n`),\n      terms: mod == \"cjs\" ? `${gen}module.exports = {\\n  ${terms.join(\",\\n  \")}\\n}`\n        : `${gen}export const\\n  ${terms.join(\",\\n  \")}\\n`\n    }\n  }\n\n  gatherNonSkippedNodes() {\n    let seen: {[term: number]: boolean} = Object.create(null)\n    let work: Term[] = []\n    let add = (term: Term) => {\n      if (!seen[term.id]) {\n        seen[term.id] = true\n        work.push(term)\n      }\n    }\n    this.terms.tops.forEach(add)\n    for (let i = 0; i < work.length; i++) {\n      for (let rule of work[i].rules) for (let part of rule.parts) add(part)\n    }\n    return seen\n  }\n\n  gatherNodeProps(nodeTypes: readonly Term[]) {\n    let notSkipped = this.gatherNonSkippedNodes(), skippedTypes = []\n    let nodeProps: {prop: string, values: {[val: string]: number[]}}[] = []\n    for (let type of nodeTypes) {\n      if (!notSkipped[type.id] && !type.error) skippedTypes.push(type.id)\n      for (let prop in type.props) {\n        let known = this.knownProps[prop]\n        if (!known) throw new GenError(\"No known prop type for \" + prop)\n        if (known.source.from == null && (known.source.name == \"repeated\" || known.source.name == \"error\")) continue\n        let rec = nodeProps.find(r => r.prop == prop)\n        if (!rec) nodeProps.push(rec = {prop, values: {}})\n        ;(rec.values[type.props[prop]] || (rec.values[type.props[prop]] = [])).push(type.id)\n      }\n    }\n    return {\n      nodeProps: nodeProps.map(({prop, values}) => {\n        let terms: (string | number)[] = []\n        for (let val in values) {\n          let ids = values[val]\n          if (ids.length == 1) {\n            terms.push(ids[0], val)\n          } else {\n            terms.push(-ids.length)\n            for (let id of ids) terms.push(id)\n            terms.push(val)\n          }\n        }\n        return {prop, terms}\n      }),\n      skippedTypes\n    }\n  }\n\n  addNestedParsers(table: readonly LRState[]) {\n    for (let state of table) {\n      let nest = state.set.filter(pos => this.nestedParsers.some(g => g.placeholder == pos.next))\n      if (nest.length) {\n        let placeholder = nest[0].next\n        if (!nest.every(pos => pos.next == placeholder))\n          this.raise(`Multiple nested grammars possible after ${nest[0].trail()}`)\n        if (!state.set.every(pos => pos.next == placeholder || (pos.pos == 0 && state.set.some(p => p.next == pos.rule.name))))\n          this.raise(`Nested grammar in ambiguous position after ${nest[0].trail()} ` + state.set)\n        state.nested = this.nestedParsers.findIndex(g => g.placeholder == placeholder)\n      }\n    }\n  }\n\n  makeTerminal(name: string, tag: string | null, props: Props) {\n    return this.terms.makeTerminal(this.terms.uniqueName(name), tag, props)\n  }\n\n  computeForceReductions(states: readonly LRState[], skipInfo: readonly SkipInfo[]) {\n    // This finds a forced reduction for every state, trying to guard\n    // against cyclic forced reductions, where a given parse stack can\n    // endlessly continue running forced reductions without making any\n    // progress.\n    //\n    // This occurs with length-1 reductions. We never generate\n    // length-0 reductions, and length-2+ reductions always shrink the\n    // stack, so they are guaranteed to make progress.\n    //\n    // If there are states S1 and S2 whose forced reductions reduce\n    // terms T1 and T2 respectively, both with a length of 1, _and_\n    // there is a state S3, which has goto entries T1 -> S2, T2 -> S1,\n    // you can get cyclic reductions. Of course, the cycle may also\n    // contain more than two steps.\n    let reductions: number[] = []\n    let candidates: Pos[][] = []\n    // A map from terms to states that they are mapped to in goto\n    // entries.\n    let gotoEdges: {[term: number]: {parents: number[], target: number}[]} = Object.create(null)\n    for (let state of states) {\n      reductions.push(0)\n      for (let edge of state.goto) {\n        let array = gotoEdges[edge.term.id] || (gotoEdges[edge.term.id] = [])\n        let found = array.find(o => o.target == edge.target.id)\n        if (found) found.parents.push(state.id)\n        else array.push({parents: [state.id], target: edge.target.id})\n      }\n      candidates[state.id] = state.set.filter(pos => pos.pos > 0 && !pos.rule.name.top)\n        .sort((a, b) => b.pos - a.pos || a.rule.parts.length - b.rule.parts.length)\n    }\n    // Mapping from state ids to terms that that state has a length-1\n    // forced reduction for.\n    let length1Reductions: {[state: number]: number} = Object.create(null)\n    function createsCycle(term: number, startState: number, parents: number[] | null = null): boolean {\n      let edges = gotoEdges[term]\n      if (!edges) return false\n      return edges.some(val => {\n        let parentIntersection = parents ? parents.filter(id => val.parents.includes(id)) : val.parents\n        if (parentIntersection.length == 0) return false\n        if (val.target == startState) return true\n        let found = length1Reductions[val.target]\n        return found != null && createsCycle(found, startState, parentIntersection)\n      })\n    }\n\n    for (let state of states) {\n      if (state.defaultReduce && state.defaultReduce.parts.length > 0) {\n        reductions[state.id] = reduceAction(state.defaultReduce, skipInfo)\n        if (state.defaultReduce.parts.length == 1) length1Reductions[state.id] = state.defaultReduce.name.id\n      }\n    }\n    // To avoid painting states that only have one potential forced\n    // reduction into a corner, reduction assignment is done by\n    // candidate size, starting with the states with fewer candidates.\n    for (let setSize = 1;; setSize++) {\n      let done = true\n      for (let state of states) {\n        if (state.defaultReduce) continue\n        let set = candidates[state.id]\n        if (set.length != setSize) {\n          if (set.length > setSize) done = false\n          continue\n        }\n        for (let pos of set) {\n          if (pos.pos != 1 || !createsCycle(pos.rule.name.id, state.id)) {\n            reductions[state.id] = reduceAction(pos.rule, skipInfo, pos.pos)\n            if (pos.pos == 1) length1Reductions[state.id] = pos.rule.name.id\n            break\n          }\n        }\n      }\n      if (done) break\n    }\n    return reductions\n  }\n\n  substituteArgs(expr: Expression, args: readonly Expression[], params: readonly Identifier[]) {\n    if (args.length == 0) return expr\n    return expr.walk(expr => {\n      let found\n      if (expr instanceof NameExpression && !expr.namespace &&\n          (found = params.findIndex(p => p.name == expr.id.name)) > -1) {\n        let arg = args[found]\n        if (expr.args.length) {\n          if (arg instanceof NameExpression && !arg.args.length)\n            return new NameExpression(expr.start, arg.namespace, arg.id, expr.args)\n          this.raise(`Passing arguments to a parameter that already has arguments`, expr.start)\n        }\n        return arg\n      } else if (expr instanceof InlineRuleExpression) {\n        let r = expr.rule, props = this.substituteArgsInProps(r.props, args, params)\n        return props == r.props ? expr :\n          new InlineRuleExpression(expr.start, new RuleDeclaration(r.start, r.id, props, r.params, r.expr))\n      } else if (expr instanceof SpecializeExpression) {\n        let props = this.substituteArgsInProps(expr.props, args, params)\n        return props == expr.props ? expr :\n          new SpecializeExpression(expr.start, expr.type, props, expr.token, expr.content)\n      }\n      return expr\n    })\n  }\n\n  substituteArgsInProps(props: readonly Prop[], args: readonly Expression[], params: readonly Identifier[]) {\n    let substituteInValue = (value: readonly PropPart[]) => {\n      let result = value as PropPart[]\n      for (let i = 0; i < value.length; i++) {\n        let part = value[i]\n        if (!part.name) continue\n        let found = params.findIndex(p => p.name == part.name)\n        if (found < 0) continue\n        if (result == value) result = value.slice()\n        let expr = args[found]\n        if (expr instanceof NameExpression && !expr.namespace && !expr.args.length)\n          result[i] = new PropPart(part.start, expr.id.name, null)\n        else if (expr instanceof LiteralExpression)\n          result[i] = new PropPart(part.start, expr.value, null)\n        else\n          this.raise(`Trying to interpolate expression '${expr}' into a prop`, part.start)\n      }\n      return result\n    }\n    let result = props as Prop[]\n    for (let i = 0; i < props.length; i++) {\n      let prop = props[i], value = substituteInValue(prop.value)\n      if (value != prop.value) {\n        if (result == props) result = props.slice()\n        result[i] = new Prop(prop.start, prop.at, prop.name, value)\n      }\n    }\n    return result\n  }\n\n  conflictsFor(markers: readonly ConflictMarker[]) {\n    let here = Conflicts.none, atEnd = Conflicts.none\n    for (let marker of markers) {\n      if (marker.type == \"ambig\") {\n        here = here.join(new Conflicts(0, [marker.id.name]))\n      } else {\n        let precs = this.ast.precedences!\n        let index = precs ? precs.items.findIndex(item => item.id.name == marker.id.name) : -1\n        if (index < 0) this.raise(`Reference to unknown precedence: '${marker.id.name}'`, marker.id.start)\n        let prec = precs.items[index], value = precs.items.length - index\n        if (prec.type == \"cut\") {\n          here = here.join(new Conflicts(0, none, value))\n        } else {\n          here = here.join(new Conflicts(value << 2))\n          atEnd = atEnd.join(new Conflicts((value << 2) + (prec.type == \"left\" ? 1 : prec.type == \"right\" ? -1 : 0)))\n        }\n      }\n    }\n    return {here, atEnd}\n  }\n\n  raise(message: string, pos = 1): never {\n    return this.input.raise(message, pos)\n  }\n\n  warn(message: string, pos = -1) {\n    let msg = this.input.message(message, pos)\n    if (this.options.warn) this.options.warn(msg)\n    else console.warn(msg)\n  }\n\n  defineRule(name: Term, choices: Parts[]) {\n    let skip = this.currentSkip[this.currentSkip.length - 1]\n    for (let choice of choices)\n      this.rules.push(new Rule(name, choice.terms, choice.ensureConflicts(), skip))\n  }\n\n  resolve(expr: NameExpression): Parts[] {\n    if (expr.namespace) {\n      let ns = this.namespaces[expr.namespace.name]\n      if (!ns)\n        this.raise(`Reference to undefined namespace '${expr.namespace.name}'`, expr.start)\n      return ns.resolve(expr, this)\n    } else {\n      for (let built of this.built) if (built.matches(expr)) return [p(built.term)]\n\n      let found = this.tokens.getToken(expr)\n      if (found) return [p(found)]\n      for (let ext of this.externalTokens) {\n        let found = ext.getToken(expr)\n        if (found) return [p(found)]\n      }\n      for (let ext of this.externalSpecializers) {\n        let found = ext.getToken(expr)\n        if (found) return [p(found)]\n      }\n\n      let known = this.astRules.find(r => r.rule.id.name == expr.id.name)\n      if (!known)\n        return this.raise(`Reference to undefined rule '${expr.id.name}'`, expr.start)\n      if (known.rule.params.length != expr.args.length)\n        this.raise(`Wrong number or arguments for '${expr.id.name}'`, expr.start)\n      this.used(known.rule.id.name)\n      return [p(this.buildRule(known.rule, expr.args, known.skip))]\n    }\n  }\n\n  // For tree-balancing reasons, repeat expressions X+ have to be\n  // normalized to something like\n  //\n  //     R -> X | R R\n  //\n  // Returns the `R` term.\n  normalizeRepeat(expr: RepeatExpression) {\n    let known = this.built.find(b => b.matchesRepeat(expr))\n    if (known) return p(known.term)\n\n    let name = expr.expr.prec < expr.prec ? `(${expr.expr})+` : `${expr.expr}+`\n    let term = this.terms.makeRepeat(this.terms.uniqueName(name))\n    this.built.push(new BuiltRule(\"+\", [expr.expr], term))\n\n    this.defineRule(term, this.normalizeExpr(expr.expr).concat(p(term, term)))\n    return p(term)\n  }\n\n  normalizeSequence(expr: SequenceExpression) {\n    let result: Parts[][] = expr.exprs.map(e => this.normalizeExpr(e))\n    let builder = this\n    function complete(start: Parts, from: number, endConflicts: Conflicts): Parts[] {\n      let {here, atEnd} = builder.conflictsFor(expr.markers[from])\n      if (from == result.length)\n        return [start.withConflicts(start.terms.length, here.join(endConflicts))]\n      let choices = []\n      for (let choice of result[from]) {\n        for (let full of complete(start.concat(choice).withConflicts(start.terms.length, here),\n                                  from + 1, endConflicts.join(atEnd)))\n          choices.push(full)\n      }\n      return choices\n    }\n    return complete(Parts.none, 0, Conflicts.none)\n  }\n\n  normalizeExpr(expr: Expression): Parts[] {\n    if (expr instanceof RepeatExpression && expr.kind == \"?\") {\n      return [Parts.none, ...this.normalizeExpr(expr.expr)]\n    } else if (expr instanceof RepeatExpression) {\n      let repeated = this.normalizeRepeat(expr)\n      return expr.kind == \"+\" ? [repeated] : [Parts.none, repeated]\n    } else if (expr instanceof ChoiceExpression) {\n      return expr.exprs.reduce((o, e) => o.concat(this.normalizeExpr(e)), [] as Parts[])\n    } else if (expr instanceof SequenceExpression) {\n      return this.normalizeSequence(expr)\n    } else if (expr instanceof LiteralExpression) {\n      return [p(this.tokens.getLiteral(expr)!)]\n    } else if (expr instanceof NameExpression) {\n      return this.resolve(expr)\n    } else if (expr instanceof SpecializeExpression) {\n      return [p(this.resolveSpecialization(expr))]\n    } else if (expr instanceof InlineRuleExpression) {\n      return [p(this.buildRule(expr.rule, none, this.currentSkip[this.currentSkip.length - 1], true))]\n    } else {\n      return this.raise(`This type of expression ('${expr}') may not occur in non-token rules`, expr.start)\n    }\n  }\n\n  buildRule(rule: RuleDeclaration, args: readonly Expression[], skip: Term, inline = false): Term {\n    let expr = this.substituteArgs(rule.expr, args, rule.params)\n    let {name: nodeName, props, dynamicPrec, inline: explicitInline, group, exported} =\n      this.nodeInfo(rule.props || none, inline ? \"pg\" : \"pgi\", rule.id.name, args, rule.params, rule.expr)\n    if (exported && rule.params.length) this.warn(`Can't export parameterized rules`, rule.start)\n    let name = this.newName(rule.id.name + (args.length ? \"<\" + args.join(\",\") + \">\" : \"\"), nodeName || true, props)\n    if (explicitInline) name.inline = true\n    if (dynamicPrec) this.registerDynamicPrec(name, dynamicPrec)\n    if ((name.nodeType || exported) && rule.params.length == 0) {\n      if (!nodeName) name.preserve = true\n      this.namedTerms[rule.id.name] = name\n    }\n\n    if (!inline) this.built.push(new BuiltRule(rule.id.name, args, name))\n    this.currentSkip.push(skip)\n    this.defineRule(name, this.normalizeExpr(expr))\n    this.currentSkip.pop()\n    if (group) this.definedGroups.push({name, group, rule})\n    return name\n  }\n\n  nodeInfo(props: readonly Prop[],\n           // p for dynamic precedence, d for dialect, i for inline, g for group, t for top\n           allow: string,\n           defaultName: string | null = null,\n           args: readonly Expression[] = none, params: readonly Identifier[] = none,\n           expr?: Expression, defaultProps?: Props): {\n    name: string | null,\n    props: Props,\n    dialect: number | null,\n    dynamicPrec: number,\n    inline: boolean,\n    group: string | null,\n    exported: boolean\n  } {\n    let result: Props = {}\n    let name = defaultName && (allow.indexOf(\"t\") > -1 || !ignored(defaultName)) && !/ /.test(defaultName) ? defaultName : null\n    let dialect = null, dynamicPrec = 0, inline = false, group: string | null = null, exported = false\n    for (let prop of props) {\n      if (!prop.at) {\n        if (!this.knownProps[prop.name]) {\n          let builtin = [\"name\", \"dialect\", \"dynamicPrecedence\", \"export\", \"isGroup\"].includes(prop.name)\n            ? ` (did you mean '@${prop.name}'?)` : \"\"\n          this.raise(`Unknown prop name '${prop.name}'${builtin}`, prop.start)\n        }\n        result[prop.name] = this.finishProp(prop, args, params)\n      } else if (prop.name == \"name\") {\n        name = this.finishProp(prop, args, params)\n        if (/ /.test(name)) this.raise(`Node names cannot have spaces ('${name}')`, prop.start)\n      } else if (prop.name == \"dialect\") {\n        if (allow.indexOf(\"d\") < 0)\n          this.raise(\"Can't specify a dialect on non-token rules\", props[0].start)\n        if (prop.value.length != 1 && !prop.value[0].value)\n          this.raise(\"The '@dialect' rule prop must hold a plain string value\")\n        let dialectID = this.dialects.indexOf(prop.value[0].value!)\n        if (dialectID < 0) this.raise(`Unknown dialect '${prop.value[0].value}'`, prop.value[0].start)\n        dialect = dialectID\n      } else if (prop.name == \"dynamicPrecedence\") {\n        if (allow.indexOf(\"p\") < 0)\n          this.raise(\"Dynamic precedence can only be specified on nonterminals\")\n        if (prop.value.length != 1 || !/^-?(?:10|\\d)$/.test(prop.value[0].value!))\n          this.raise(\"The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10\")\n        dynamicPrec = +prop.value[0].value!\n      } else if (prop.name == \"inline\") {\n        if (prop.value.length) this.raise(\"'@inline' doesn't take a value\", prop.value[0].start)\n        if (allow.indexOf(\"i\") < 0) this.raise(\"Inline can only be specified on nonterminals\")\n        inline = true\n      } else if (prop.name == \"isGroup\") {\n        if (allow.indexOf(\"g\") < 0) this.raise(\"'@isGroup' can only be specified on nonterminals\")\n        group = prop.value.length ? this.finishProp(prop, args, params) : defaultName\n      } else if (prop.name == \"export\") {\n        if (prop.value.length) this.raise(\"'@export' doesn't take a value\", prop.value[0].start)\n        exported = true\n      } else {\n        this.raise(`Unknown built-in prop name '@${prop.name}'`, prop.start)\n      }\n    }\n    if (expr && this.ast.autoDelim && (name || hasProps(result))) {\n      let delim = this.findDelimiters(expr)\n      if (delim) {\n        addToProp(delim[0], \"closedBy\", delim[1].nodeName!)\n        addToProp(delim[1], \"openedBy\", delim[0].nodeName!)\n      }\n    }\n    if (defaultProps && hasProps(defaultProps)) {\n      for (let prop in defaultProps) if (!(prop in result)) result[prop] = defaultProps[prop]\n    }\n    if (hasProps(result) && !name)\n      this.raise(`Node has properties but no name`, props.length ? props[0].start : expr!.start)\n    if (inline && (hasProps(result) || dialect || dynamicPrec))\n      this.raise(`Inline nodes can't have props, dynamic precedence, or a dialect`, props[0].start)\n    if (inline && name) name = null\n    return {name, props: result, dialect, dynamicPrec, inline, group, exported}\n  }\n\n  finishProp(prop: Prop, args: readonly Expression[], params: readonly Identifier[]): string {\n    return prop.value.map(part => {\n      if (part.value) return part.value\n      let pos = params.findIndex(param => param.name == part.name)\n      if (pos < 0) this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`, part.start)\n      let expr = args[pos]\n      if (expr instanceof NameExpression && !expr.args.length && !expr.namespace) return expr.id.name\n      if (expr instanceof LiteralExpression) return expr.value\n      return this.raise(`Expression '${expr}' can not be used as part of a property value`, part.start)\n    }).join(\"\")\n  }\n\n  resolveSpecialization(expr: SpecializeExpression) {\n    let type = expr.type\n    let {name, props, dialect} = this.nodeInfo(expr.props, \"d\")\n    let terminal = this.normalizeExpr(expr.token)\n    if (terminal.length != 1 || terminal[0].terms.length != 1 || !terminal[0].terms[0].terminal)\n      this.raise(`The first argument to '${type}' must resolve to a token`, expr.token.start)\n    let values\n    if (expr.content instanceof LiteralExpression)\n      values = [expr.content.value]\n    else if ((expr.content instanceof ChoiceExpression) && expr.content.exprs.every(e => e instanceof LiteralExpression))\n      values = expr.content.exprs.map(expr => (expr as LiteralExpression).value)\n    else\n      return this.raise(`The second argument to '${expr.type}' must be a literal or choice of literals`, expr.content.start)\n\n    let term = terminal[0].terms[0], token = null\n    let table = this.specialized[term.name] || (this.specialized[term.name] = [])\n    for (let value of values) {\n      let known = table.find(sp => sp.value == value)\n      if (known == null) {\n        if (!token) {\n          token = this.makeTerminal(term.name + \"/\" + JSON.stringify(value), name, props)\n          if (dialect != null) (this.tokens.byDialect[dialect] || (this.tokens.byDialect[dialect] = [])).push(token)\n        }\n        table.push({value, term: token, type, dialect, name})\n        this.tokenOrigins[token.name] = {spec: term}\n      } else {\n        if (known.type != type)\n          this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${term.name} (${type} vs ${known.type})`,\n                     expr.start)\n        if (known.dialect != dialect)\n          this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start)\n        if (known.name != name)\n          this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start)\n        if (token && known.term != token)\n          this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${term.name}`, expr.start)\n        token = known.term\n      }\n    }\n    return token!\n  }\n\n  findDelimiters(expr: Expression) {\n    if (!(expr instanceof SequenceExpression) || expr.exprs.length < 2) return null\n    let findToken = (expr: Expression): {term: Term, str: string} | null => {\n      if (expr instanceof LiteralExpression) return {term: this.tokens.getLiteral(expr), str: expr.value}\n      if (expr instanceof NameExpression && expr.args.length == 0) {\n        let rule = this.ast.rules.find(r => r.id.name == expr.id.name)\n        if (rule) return findToken(rule.expr)\n        let token = this.tokens.rules.find(r => r.id.name == expr.id.name)\n        if (token && token.expr instanceof LiteralExpression) return {term: this.tokens.getToken(expr)!, str: token.expr.value}\n      }\n      return null\n    }\n    let lastToken = findToken(expr.exprs[expr.exprs.length - 1])\n    if (!lastToken || !lastToken.term.nodeName) return null\n    const brackets = [\"()\", \"[]\", \"{}\", \"<>\"]\n    let bracket = brackets.find(b => lastToken!.str.indexOf(b[1]) > -1 && lastToken!.str.indexOf(b[0]) < 0)\n    if (!bracket) return null\n    let firstToken = findToken(expr.exprs[0])\n    if (!firstToken || !firstToken.term.nodeName ||\n        firstToken.str.indexOf(bracket[0]) < 0 || firstToken.str.indexOf(bracket[1]) > -1) return null\n    return [firstToken.term, lastToken.term]\n  }\n\n  registerDynamicPrec(term: Term, prec: number) {\n    this.dynamicRulePrecedences.push({rule: term, prec})\n    term.preserve = true\n  }\n\n  defineGroup(rule: Term, group: string, ast: RuleDeclaration) {\n    let recur: Term[] = []\n    let getNamed = (rule: Term): Term[] => {\n      if (rule.nodeName) return [rule]\n      if (recur.includes(rule))\n        this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`,\n                   ast.start)\n      let result: Term[] = []\n      recur.push(rule)\n      for (let r of this.rules) if (r.name == rule) {\n        let names = r.parts.map(getNamed).filter(x => x.length)\n        if (names.length > 1)\n          this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`, ast.start)\n        if (names.length == 1) for (let n of names[0]) result.push(n)\n      }\n      recur.pop()\n      return result\n    }\n\n    for (let name of getNamed(rule))\n      name.props[\"group\"] = (name.props[\"group\"]?.split(\" \") || []).concat(group).sort().join(\" \")\n  }\n\n  checkGroups() {\n    let groups: {[name: string]: Term[]} = Object.create(null), nodeNames: {[name: string]: boolean} = Object.create(null)\n    for (let term of this.terms.terms) if (term.nodeName) {\n      nodeNames[term.nodeName] = true\n      if (term.props[\"group\"]) for (let group of term.props[\"group\"].split(\" \")) {\n        ;(groups[group] || (groups[group] = [])).push(term)\n      }\n    }\n    let names = Object.keys(groups)\n    for (let i = 0; i < names.length; i++) {\n      let name = names[i], terms = groups[name]\n      if (nodeNames[name]) this.warn(`Group name '${name}' conflicts with a node of the same name`)\n      for (let j = i + 1; j < names.length; j++) {\n        let other = groups[names[j]]\n        if (terms.some(t => other.includes(t)) &&\n            (terms.length > other.length ? other.some(t => !terms.includes(t)) : terms.some(t => !other.includes(t))))\n          this.warn(`Groups '${name}' and '${names[j]}' overlap without one being a superset of the other`)\n      }\n    }\n  }\n}\n\nconst MinSharedActions = 5\n\ntype SharedActions = {actions: readonly (Shift | Reduce)[], addr: number}\n\nclass FinishStateContext {\n  sharedActions: SharedActions[] = []\n\n  constructor(\n    readonly tokenizers: (TokenGroup | ExternalTokenDeclaration)[],\n    readonly data: DataBuilder,\n    readonly stateArray: Uint32Array,\n    readonly skipData: readonly number[],\n    readonly skipInfo: readonly SkipInfo[],\n    readonly states: readonly LRState[],\n    readonly builder: Builder\n  ) {}\n\n  findSharedActions(state: LRState): SharedActions | null {\n    if (state.actions.length < MinSharedActions) return null\n    let found = null\n    for (let shared of this.sharedActions) {\n      if ((!found || shared.actions.length > found.actions.length) &&\n          shared.actions.every(a => state.actions.some(b => b.eq(a))))\n        found = shared\n    }\n    if (found) return found\n    let max: (Shift | Reduce)[] | null = null, scratch = []\n    for (let i = state.id + 1; i < this.states.length; i++) {\n      let other = this.states[i], fill = 0\n      if (other.defaultReduce || other.actions.length < MinSharedActions) continue\n      for (let a of state.actions) for (let b of other.actions) if (a.eq(b)) scratch[fill++] = a\n      if (fill >= MinSharedActions && (!max || max.length < fill)) {\n        max = scratch\n        scratch = []\n      }\n    }\n    if (!max) return null\n    let result = {actions: max, addr: this.storeActions(max, -1, null)}\n    this.sharedActions.push(result)\n    return result\n  }\n\n  storeActions(actions: readonly (Shift | Reduce)[], skipReduce: number, shared: SharedActions | null) {\n    if (skipReduce < 0 && shared && shared.actions.length == actions.length) return shared.addr\n\n    let data = []\n    for (let action of actions) {\n      if (shared && shared.actions.some(a => a.eq(action))) continue\n      if (action instanceof Shift) {\n        data.push(action.term.id, action.target.id, 0)\n      } else {\n        let code = reduceAction(action.rule, this.skipInfo)\n        if (code != skipReduce) data.push(action.term.id, code & Action.ValueMask, code >> 16)\n      }\n    }\n    data.push(Seq.End)\n    if (skipReduce > -1) data.push(Seq.Other, skipReduce & Action.ValueMask, skipReduce >> 16)\n    else if (shared) data.push(Seq.Next, shared.addr & 0xffff, shared.addr >> 16)\n    else data.push(Seq.Done)\n    return this.data.storeArray(data)\n  }\n\n  finish(state: LRState, isSkip: boolean, forcedReduce: number) {\n    let b = this.builder\n    let skipID = b.skipRules.indexOf(state.skip)\n    let skipTable = this.skipData[skipID], skipTerms = this.skipInfo[skipID].startTokens\n\n    let defaultReduce = state.defaultReduce ? reduceAction(state.defaultReduce, this.skipInfo) : 0\n    let flags = (isSkip ? StateFlag.Skipped : 0) |\n      (state.nested > -1 ? StateFlag.StartNest | (state.nested << StateFlag.NestShift) : 0)\n\n    let skipReduce = -1, shared = null\n    if (defaultReduce == 0) {\n      for (const action of state.actions)\n        if (action instanceof Reduce && action.term.eof && this.skipInfo.some(i => i.rule == action.rule.name))\n          skipReduce = reduceAction(action.rule, this.skipInfo)\n      if (skipReduce < 0) shared = this.findSharedActions(state)\n    }\n\n    if (state.set.some(p => p.rule.name.top && p.pos == p.rule.parts.length)) flags |= StateFlag.Accepting\n\n    let external: ExternalTokenDeclaration[] = []\n    for (let i = 0; i < state.actions.length + skipTerms.length; i++) {\n      let term = i < state.actions.length ? state.actions[i].term : skipTerms[i - state.actions.length]\n      for (;;) {\n        let orig = b.tokenOrigins[term.name]\n        if (orig && orig.spec) { term = orig.spec; continue }\n        if (orig && (orig.external instanceof ExternalTokenSet)) addToSet(external, orig.external.ast)\n        break\n      }\n    }\n    external.sort((a, b) => a.start - b.start)\n    let tokenizerMask = 0\n    for (let i = 0; i < this.tokenizers.length; i++) {\n      let tok = this.tokenizers[i]\n      if (tok instanceof ExternalTokenDeclaration ? external.includes(tok) : tok.id == state.tokenGroup)\n        tokenizerMask |= (1 << i)\n    }\n\n    let base = state.id * ParseState.Size\n    this.stateArray[base + ParseState.Flags] = flags\n    this.stateArray[base + ParseState.Actions] = this.storeActions(defaultReduce ? none : state.actions, skipReduce, shared)\n    this.stateArray[base + ParseState.Skip] = skipTable\n    this.stateArray[base + ParseState.TokenizerMask] = tokenizerMask\n    this.stateArray[base + ParseState.DefaultReduce] = defaultReduce\n    this.stateArray[base + ParseState.ForcedReduce] = forcedReduce\n  }\n}\n\nfunction addToProp(term: Term, prop: string, value: string) {\n  let cur = term.props[prop]\n  if (!cur || cur.split(\" \").indexOf(value) < 0) term.props[prop] = cur ? cur + \" \" + value : value\n}\n\nfunction buildSpecializeTable(spec: {value: string, term: Term, type: string}[]): {[value: string]: number} {\n  let table: {[value: string]: number} = Object.create(null)\n  for (let {value, term, type} of spec) {\n    let code = type == \"specialize\" ? Specialize.Specialize : Specialize.Extend\n    table[value] = (term.id << 1) | code\n  }\n  return table\n}\n\nfunction reduceAction(rule: Rule, skipInfo: readonly SkipInfo[], depth = rule.parts.length) {\n  return rule.name.id | Action.ReduceFlag |\n    (rule.isRepeatWrap && depth == rule.parts.length ? Action.RepeatFlag : 0) |\n    (skipInfo.some(i => i.rule == rule.name) ? Action.StayFlag : 0) |\n    (depth << Action.ReduceDepthShift)\n}\n\nfunction findArray(data: number[], value: number[]) {\n  search: for (let i = 0;;) {\n    let next = data.indexOf(value[0], i)\n    if (next == -1 || next + value.length > data.length) break\n    for (let j = 1; j < value.length; j++) {\n      if (value[j] != data[next + j]) {\n        i = next + 1\n        continue search\n      }\n    }\n    return next\n  }\n  return -1\n}\n\nfunction findSkipStates(table: readonly LRState[], startRules: readonly Term[]) {\n  let nonSkip: {[id: number]: boolean} = Object.create(null)\n  let work: LRState[] = []\n  let add = (state: LRState) => {\n    if (!nonSkip[state.id]) {\n      nonSkip[state.id] = true\n      work.push(state)\n    }\n  }\n  for (let state of table) if (state.startRule && startRules.includes(state.startRule)) add(state)\n  for (let i = 0; i < work.length; i++) {\n    for (let a of work[i].actions) if (a instanceof Shift) add(a.target)\n    for (let a of work[i].goto) add(a.target)\n  }\n  return (id: number) => !nonSkip[id]\n}\n\nclass DataBuilder {\n  data: number[] = []\n\n  storeArray(data: number[]) {\n    let found = findArray(this.data, data)\n    if (found > -1) return found\n    let pos = this.data.length\n    for (let num of data) this.data.push(num)\n    return pos\n  }\n\n  finish() {\n    return Uint16Array.from(this.data)\n  }\n}\n\n// The goto table maps a start state + a term to a new state, and is\n// used to determine the new state when reducing. Because this allows\n// more more efficient representation and access, unlike the action\n// tables, the goto table is organized by term, with groups of start\n// states that map to a given end state enumerated for each term.\n// Since many terms only have a single valid goto target, this makes\n// it cheaper to look those up.\n//\n// (Unfortunately, though the standard LR parsing mechanism never\n// looks up invalid goto states, the incremental parsing mechanism\n// needs accurate goto information for a state/term pair, so we do\n// need to store state ids even for terms that have only one target.)\n//\n// - First comes the amount of terms in the table\n//\n// - Then, for each term, the offset of the term's data\n//\n// - At these offsets, there's a record for each target state\n//\n//   - Such a record starts with the amount of start states that go to\n//     this target state, shifted one to the left, with the first bit\n//     only set if this is the last record for this term.\n//\n//   - Then follows the target state id\n//\n//   - And then the start state ids\nfunction computeGotoTable(states: readonly LRState[]) {\n  let goto: {[term: number]: {[to: number]: number[]}} = {}\n  let maxTerm = 0\n  for (let state of states) {\n    for (let entry of state.goto) {\n      maxTerm = Math.max(entry.term.id, maxTerm)\n      let set = goto[entry.term.id] || (goto[entry.term.id] = {})\n      ;(set[entry.target.id] || (set[entry.target.id] = [])).push(state.id)\n    }\n  }\n  let data = new DataBuilder\n  let index: number[] = []\n  let offset = maxTerm + 2 // Offset of the data, taking index size into account\n\n  for (let term = 0; term <= maxTerm; term++) {\n    let entries = goto[term]\n    if (!entries) {\n      index.push(1)\n      continue\n    }\n    let termTable: number[] = []\n    let keys = Object.keys(entries)\n    for (let target of keys) {\n      let list = entries[target as any]\n      termTable.push((target == keys[keys.length - 1] ? 1 : 0) + (list.length << 1))\n      termTable.push(+target)\n      for (let source of list) termTable.push(source)\n    }\n    index.push(data.storeArray(termTable) + offset)\n  }\n  if (index.some(n => n > 0xffff)) throw new GenError(\"Goto table too large\")\n\n  return Uint16Array.from([maxTerm + 1, ...index, ...data.data])\n}\n\nclass TokenGroup {\n  constructor(readonly tokens: Term[], readonly id: number) {}\n}\n\nfunction addToSet<T>(set: T[], value: T) {\n  if (!set.includes(value)) set.push(value)\n}\n\nfunction buildTokenMasks(groups: TokenGroup[]) {\n  let masks: {[id: number]: number} = Object.create(null)\n  for (let group of groups) {\n    let groupMask = 1 << group.id\n    for (let term of group.tokens) {\n      masks[term.id] = (masks[term.id] || 0) | groupMask\n    }\n  }\n  return masks\n}\n\ninterface Namespace {\n  resolve(expr: NameExpression, builder: Builder): Parts[]\n}\n\nclass NestedParserSpec {\n  constructor(readonly placeholder: Term,\n              readonly name: string,\n              readonly extName: string,\n              readonly source: string | null,\n              readonly end: State) {}\n}\n\nclass NestNamespace implements Namespace {\n  resolve(expr: NameExpression, builder: Builder): Parts[] {\n    if (expr.args.length > 2)\n      builder.raise(`Too many arguments to 'nest.${expr.id.name}'`, expr.start)\n    let [endExpr, defaultExpr] = expr.args as [Expression | undefined, Expression | undefined]\n    let extGrammar = builder.ast.grammars.find(g => g.id.name == expr.id.name)\n    if (!extGrammar) return builder.raise(`No external grammar '${expr.id.name}' defined`, expr.id.start)\n    let placeholder = builder.newName(expr.id.name + \"-placeholder\", true)\n    builder.defineRule(placeholder, defaultExpr ? builder.normalizeExpr(defaultExpr) : [])\n\n    if (!endExpr && !(endExpr = findExprAfter(builder.ast, expr)))\n      return builder.raise(`No end token specified, and no token found directly after the nest expression`, expr.start)\n    let endStart = new State, endEnd = new State([builder.terms.eof])\n    try {\n      builder.tokens.build(endExpr, endStart, endEnd, none)\n    } catch(e) {\n      if (!(e instanceof SyntaxError)) throw e\n      builder.raise(`End token '${endExpr}' for nested grammar is not a valid token expression`, endExpr.start)\n    }\n    builder.nestedParsers.push(new NestedParserSpec(placeholder, extGrammar.id.name, extGrammar.externalID.name,\n                                                    extGrammar.source, endStart))\n    if (builder.nestedParsers.length >= 2**(30 - StateFlag.NestShift))\n      builder.raise(\"Too many nested grammars used\")\n    return [p(placeholder)]\n  }\n}\n\nfunction findExprAfter(ast: GrammarDeclaration, expr: Expression) {\n  let found: Expression | undefined\n  function walk(cur: Expression) {\n    if (cur instanceof SequenceExpression) {\n      let index = cur.exprs.indexOf(expr)\n      if (index > -1 && index < cur.exprs.length - 1) found = cur.exprs[index + 1]\n    }\n    return cur\n  }\n  for (let rule of ast.rules) rule.expr.walk(walk)\n  for (let topRule of ast.topRules) topRule.expr.walk(walk)\n  return found\n}\n\nclass TokenArg {\n  constructor(readonly name: string, readonly expr: Expression, readonly scope: readonly TokenArg[]) {}\n}\n\nclass BuildingRule {\n  constructor(readonly name: string, readonly start: State, readonly to: State, readonly args: readonly Expression[]) {}\n}\n\nclass TokenSet {\n  startState: State = new State\n  built: BuiltRule[] = []\n  building: BuildingRule[] = [] // Used for recursion check\n  rules: readonly RuleDeclaration[]\n  byDialect: {[dialect: number]: Term[]} = Object.create(null)\n  precedenceRelations: readonly {term: Term, after: readonly Term[]}[] = []\n  explicitConflicts: {a: Term, b: Term}[] = []\n\n  constructor(readonly b: Builder, readonly ast: TokenDeclaration | null) {\n    this.rules = ast ? ast.rules : none\n    for (let rule of this.rules) this.b.unique(rule.id)\n  }\n\n  getToken(expr: NameExpression) {\n    for (let built of this.built) if (built.matches(expr)) return built.term\n    let name = expr.id.name\n    let rule = this.rules.find(r => r.id.name == name)\n    if (!rule) return null\n    let {name: nodeName, props, dialect, exported} =\n      this.b.nodeInfo(rule.props, \"d\", name, expr.args, rule.params.length != expr.args.length ? none : rule.params)\n    let term = this.b.makeTerminal(expr.toString(), nodeName, props)\n    if (dialect != null) (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term)\n\n    if ((term.nodeType || exported) && rule.params.length == 0) {\n      if (!term.nodeType) term.preserve = true\n      this.b.namedTerms[name] = term\n    }\n    this.buildRule(rule, expr, this.startState, new State([term]))\n    this.built.push(new BuiltRule(name, expr.args, term))\n    return term\n  }\n\n  getLiteral(expr: LiteralExpression) {\n    let id = JSON.stringify(expr.value)\n    for (let built of this.built) if (built.id == id) return built.term\n    let name = null, props = {}, dialect = null\n    let decl = this.ast ? this.ast.literals.find(l => l.literal == expr.value) : null\n    if (decl) ({name, props, dialect} = this.b.nodeInfo(decl.props, \"d\", expr.value))\n\n    let term = this.b.makeTerminal(id, name, props)\n    if (dialect != null) (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term)\n    this.build(expr, this.startState, new State([term]), none)\n    this.built.push(new BuiltRule(id, none, term))\n    return term\n  }\n\n  buildRule(rule: RuleDeclaration, expr: NameExpression, from: State, to: State, args: readonly TokenArg[] = none) {\n    let name = expr.id.name\n    if (rule.params.length != expr.args.length)\n      this.b.raise(`Incorrect number of arguments for token '${name}'`, expr.start)\n    let building = this.building.find(b => b.name == name && exprsEq(expr.args, b.args))\n    if (building) {\n      if (building.to == to) {\n        from.nullEdge(building.start)\n        return\n      }\n      let lastIndex = this.building.length - 1\n      while (this.building[lastIndex].name != name) lastIndex--\n      this.b.raise(`Invalid (non-tail) recursion in token rules: ${\n        this.building.slice(lastIndex).map(b => b.name).join(\" -> \")}`, expr.start)\n    }\n    this.b.used(rule.id.name)\n    let start = new State\n    from.nullEdge(start)\n    this.building.push(new BuildingRule(name, start, to, expr.args))\n    this.build(this.b.substituteArgs(rule.expr, expr.args, rule.params), start, to,\n               expr.args.map((e, i) => new TokenArg(rule!.params[i].name, e, args)))\n    this.building.pop()\n  }\n\n  build(expr: Expression, from: State, to: State, args: readonly TokenArg[]): void {\n    if (expr instanceof NameExpression) {\n      if (expr.namespace) {\n        if (expr.namespace.name == \"std\") return this.buildStd(expr, from, to)\n        this.b.raise(`Unknown namespace '${expr.namespace.name}'`, expr.start)\n      }\n      let name = expr.id.name, arg = args.find(a => a.name == name)\n      if (arg) return this.build(arg.expr, from, to, arg.scope)\n      let rule = this.rules.find(r => r.id.name == name)\n      if (!rule) return this.b.raise(`Reference to rule '${expr.id.name}', which isn't found in this token group`, expr.start)\n      this.buildRule(rule, expr, from, to, args)\n    } else if (expr instanceof ChoiceExpression) {\n      for (let choice of expr.exprs) this.build(choice, from, to, args)\n    } else if (isEmpty(expr)) {\n      from.nullEdge(to)\n    } else if (expr instanceof SequenceExpression) {\n      let conflict = expr.markers.find(c => c.length > 0)\n      if (conflict) this.b.raise(\"Conflict marker in token expression\", conflict[0].start)\n      for (let i = 0; i < expr.exprs.length; i++) {\n        let next = i == expr.exprs.length - 1 ? to : new State\n        this.build(expr.exprs[i], from, next, args)\n        from = next\n      }\n    } else if (expr instanceof RepeatExpression) {\n      if (expr.kind == \"*\") {\n        let loop = new State\n        from.nullEdge(loop)\n        this.build(expr.expr, loop, loop, args)\n        loop.nullEdge(to)\n      } else if (expr.kind == \"+\") {\n        let loop = new State\n        this.build(expr.expr, from, loop, args)\n        this.build(expr.expr, loop, loop, args)\n        loop.nullEdge(to)\n      } else { // expr.kind == \"?\"\n        from.nullEdge(to)\n        this.build(expr.expr, from, to, args)\n      }\n    } else if (expr instanceof SetExpression) {\n      for (let [a, b] of expr.inverted ? invertRanges(expr.ranges) : expr.ranges)\n        rangeEdges(from, to, a, b)\n    } else if (expr instanceof LiteralExpression) {\n      for (let i = 0; i < expr.value.length; i++) {\n        let ch = expr.value.charCodeAt(i)\n        let next = i == expr.value.length - 1 ? to : new State\n        from.edge(ch, ch + 1, next)\n        from = next\n      }\n    } else if (expr instanceof AnyExpression) {\n      from.edge(0, MAX_CHAR + 1, to)\n    } else {\n      return this.b.raise(`Unrecognized expression type in token`, (expr as any).start)\n    }\n  }\n\n  buildStd(expr: NameExpression, from: State, to: State) {\n    if (expr.args.length) this.b.raise(`'std.${expr.id.name}' does not take arguments`, expr.args[0].start)\n    if (!STD_RANGES.hasOwnProperty(expr.id.name)) this.b.raise(`There is no builtin rule 'std.${expr.id.name}'`, expr.start)\n    for (let [a, b] of STD_RANGES[expr.id.name]) from.edge(a, b, to)\n  }\n\n  takePrecedences() {\n    let rel: {term: Term, after: Term[]}[] = this.precedenceRelations = []\n    if (this.ast) for (let group of this.ast.precedences) {\n      let prev: Term[] = []\n      for (let item of group.items) {\n        let level = []\n        if (item instanceof NameExpression) {\n          for (let built of this.built)\n            if (item.args.length ? built.matches(item) : built.id == item.id.name)\n              level.push(built.term)\n        } else {\n          let id = JSON.stringify(item.value), found = this.built.find(b => b.id == id)\n          if (found) level.push(found.term)\n        }\n        if (!level.length) this.b.warn(`Precedence specified for unknown token ${item}`, item.start)\n        for (let term of level) addRel(rel, term, prev)\n        prev = prev.concat(level)\n      }\n    }\n  }\n\n  takeConflicts() {\n    let resolve = (expr: NameExpression | LiteralExpression) => {\n      if (expr instanceof NameExpression) {\n        for (let built of this.built) if (built.matches(expr)) return built.term\n      } else {\n        let id = JSON.stringify(expr.value), found = this.built.find(b => b.id == id)\n        if (found) return found.term\n      }\n      this.b.warn(`Precedence specified for unknown token ${expr}`, expr.start)\n      return null\n    }\n    for (let c of this.ast?.conflicts || []) {\n      let a = resolve(c.a), b = resolve(c.b)\n      if (a && b) {\n        if (a.id < b.id) [a, b] = [b, a]\n        this.explicitConflicts.push({a, b})\n      }\n    }\n  }\n\n  precededBy(a: Term, b: Term) {\n    let found = this.precedenceRelations.find(r => r.term == a)\n    return found && found.after.includes(b)\n  }\n\n  // Token groups are a mechanism for allowing conflicting (matching\n  // overlapping input, without an explicit precedence being given)\n  // tokens to exist in a grammar _if_ they don't occur in the same\n  // place (aren't used in the same states).\n  //\n  // States that use tokens that conflict will raise an error when any\n  // of the conflicting pairs of tokens both occur in that state.\n  // Otherwise, they are assigned a token group, which includes all\n  // the potentially-conflicting tokens they use. If there's already a\n  // group that doesn't have any conflicts with those tokens, that is\n  // reused, otherwise a new group is created.\n  //\n  // So each state has zero or one token groups, and each conflicting\n  // token may belong to one or more groups. Tokens get assigned a\n  // 16-bit bitmask with the groups they belong to set to 1 (all-1s\n  // for non-conflicting tokens). When tokenizing, that mask is\n  // compared to the current state's group (again using all-1s for\n  // group-less states) to determine whether a token is applicable for\n  // this state.\n  //\n  // Extended/specialized tokens are treated as their parent token for\n  // this purpose.\n  buildTokenGroups(states: readonly LRState[], skipInfo: readonly SkipInfo[]) {\n    let tokens = this.startState.compile()\n    if (tokens.accepting.length)\n      this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`,\n                   this.rules.find(r => r.id.name == tokens.accepting[0].name)!.start)\n    if (/\\btokens\\b/.test(verbose)) console.log(tokens.toString())\n\n    // If there is a precedence specified for the pair, the conflict is resolved\n    let allConflicts = tokens.findConflicts(checkTogether(states, this.b, skipInfo))\n      .filter(({a, b}) => !this.precededBy(a, b) && !this.precededBy(b, a))\n    for (let {a, b} of this.explicitConflicts) {\n      if (!allConflicts.some(c => c.a == a && c.b == b))\n        allConflicts.push(new Conflict(a, b, 0, \"\", \"\"))\n    }\n    let softConflicts = allConflicts.filter(c => c.soft), conflicts = allConflicts.filter(c => !c.soft)\n    let errors: {conflict: Conflict, error: string}[] = []\n\n    let groups: TokenGroup[] = []\n    for (let state of states) {\n      if (state.defaultReduce) continue\n      // Find potentially-conflicting terms (in terms) and the things\n      // they conflict with (in conflicts), and raise an error if\n      // there's a token conflict directly in this state.\n      let terms: Term[] = [], incompatible: Term[] = []\n      let skip = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens\n      for (let term of skip)\n        if (state.actions.some(a => a.term == term))\n          this.b.raise(`Use of token ${term.name} conflicts with skip rule`)\n\n      let stateTerms: Term[] = []\n      for (let i = 0; i < state.actions.length + (skip ? skip.length : 0); i++) {\n        let term = i < state.actions.length ? state.actions[i].term : skip[i - state.actions.length]\n        let orig = this.b.tokenOrigins[term.name]\n        if (orig && orig.spec) term = orig.spec\n        else if (orig && orig.external) continue\n        addToSet(stateTerms, term)\n      }\n      if (stateTerms.length == 0) continue\n\n      for (let term of stateTerms) {\n        for (let conflict of conflicts) {\n          let conflicting = conflict.a == term ? conflict.b : conflict.b == term ? conflict.a : null\n          if (!conflicting) continue\n          if (stateTerms.includes(conflicting) && !errors.some(e => e.conflict == conflict)) {\n            let example = conflict.exampleA ? ` (example: ${JSON.stringify(conflict.exampleA)}${\n              conflict.exampleB ? ` vs ${JSON.stringify(conflict.exampleB)}` : \"\"})` : \"\"\n            errors.push({\n              error: `Overlapping tokens ${term.name} and ${conflicting.name} used in same context${example}\\n` +\n                `After: ${state.set[0].trail()}`,\n              conflict\n            })\n          }\n          addToSet(terms, term)\n          addToSet(incompatible, conflicting)\n        }\n      }\n\n      let tokenGroup = null\n      for (let group of groups) {\n        if (incompatible.some(term => group.tokens.includes(term))) continue\n        for (let term of terms) addToSet(group.tokens, term)\n        tokenGroup = group\n        break\n      }\n      if (!tokenGroup) {\n        tokenGroup = new TokenGroup(terms, groups.length)\n        groups.push(tokenGroup)\n      }\n      state.tokenGroup = tokenGroup.id\n    }\n\n    if (errors.length)\n      this.b.raise(errors.map(e => e.error).join(\"\\n\\n\"))\n    if (groups.length > 16)\n      this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`)\n\n    let precTable: number[] = [], rel = this.precedenceRelations.slice()\n    // Add entries for soft-conflicting tokens that are in the\n    // precedence table, to make sure they'll appear in the right\n    // order and don't mess up the longer-wins default rule.\n    for (let {a, b, soft} of softConflicts) if (soft) {\n      if (!rel.some(r => r.term == a) || !rel.some(r => r.term == b)) continue\n      if (soft < 0) [a, b] = [b, a] // Now a is longer than b (and should thus take precedence)\n      addRel(rel, b, [a])\n      addRel(rel, a, [])\n    }\n    add: while (rel.length) {\n      for (let i = 0; i < rel.length; i++) {\n        let record = rel[i]\n        if (record.after.every(t => precTable.includes(t.id))) {\n          precTable.push(record.term.id)\n          if (rel.length == 1) break add\n          rel[i] = rel.pop()!\n          continue add\n        }\n      }\n      this.b.raise(`Cyclic token precedence relation between ${rel.map(r => r.term).join(\", \")}`)\n    }\n    precTable = precTable.filter(id => allConflicts.some(c => !c.soft && (c.a.id == id || c.b.id == id)))\n\n    return {\n      tokenGroups: groups,\n      tokenPrec: precTable,\n      tokenData: tokens.toArray(buildTokenMasks(groups), precTable)\n    }\n  }\n}\n\nfunction checkTogether(states: readonly LRState[], b: Builder, skipInfo: readonly SkipInfo[]) {\n  let cache: {[id: number]: boolean} = Object.create(null)\n  function hasTerm(state: LRState, term: Term) {\n    return state.actions.some(a => a.term == term) ||\n      skipInfo[b.skipRules.indexOf(state.skip)].startTokens.includes(term)\n  }\n  return (a: Term, b: Term) => {\n    if (a.id < b.id) [a, b] = [b, a]\n    let key = a.id | (b.id << 16), cached = cache[key]\n    if (cached != null) return cached\n    return cache[key] = states.some(state => hasTerm(state, a) && hasTerm(state, b))\n  }\n}\n\nfunction invertRanges(ranges: [number, number][]) {\n  let pos = 0, result: [number, number][] = []\n  for (let [a, b] of ranges) {\n    if (a > pos) result.push([pos, a])\n    pos = b\n  }\n  if (pos <= MAX_CODE) result.push([pos, MAX_CODE + 1])\n  return result\n}\n\nconst ASTRAL = 0x10000, GAP_START = 0xd800, GAP_END = 0xe000, MAX_CODE = 0x10ffff\nconst LOW_SURR_B = 0xdc00, HIGH_SURR_B = 0xdfff\n\n// Create intermediate states for astral characters in a range, if\n// necessary, since the tokenizer acts on UTF16 characters\nfunction rangeEdges(from: State, to: State, low: number, hi: number) {\n  if (low < GAP_START && hi == MAX_CODE + 1) {\n    from.edge(low, MAX_CHAR + 1, to)\n    return\n  }\n\n  if (low < ASTRAL) {\n    if (low < GAP_START) from.edge(low, Math.min(hi, GAP_START), to)\n    if (hi > GAP_END) from.edge(Math.max(low, GAP_END), Math.min(hi, MAX_CHAR + 1), to)\n    low = ASTRAL\n  }\n  if (hi < ASTRAL) return\n\n  let lowStr = String.fromCodePoint(low), hiStr = String.fromCodePoint(hi - 1)\n  let lowA = lowStr.charCodeAt(0), lowB = lowStr.charCodeAt(1)\n  let hiA = hiStr.charCodeAt(0), hiB = hiStr.charCodeAt(1)\n  if (lowA == hiA) { // Share the first char code\n    let hop = new State\n    from.edge(lowA, lowA + 1, hop)\n    hop.edge(lowB, hiB + 1, to)\n  } else {\n    let midStart = lowA, midEnd = hiA\n    if (lowB > LOW_SURR_B) {\n      midStart++\n      let hop = new State\n      from.edge(lowA, lowA + 1, hop)\n      hop.edge(lowB, HIGH_SURR_B + 1, to)\n    }\n    if (hiB < HIGH_SURR_B) {\n      midEnd--\n      let hop = new State\n      from.edge(hiA, hiA + 1, hop)\n      hop.edge(LOW_SURR_B, hiB + 1, to)\n    }\n    if (midStart <= midEnd) {\n      let hop = new State\n      from.edge(midStart, midEnd + 1, hop)\n      hop.edge(LOW_SURR_B, HIGH_SURR_B + 1, to)\n    }\n  }\n}\n\nconst STD_RANGES: {[name: string]: [number, number][]} = {\n  asciiLetter: [[65, 91], [97, 123]],\n  asciiLowercase: [[97, 123]],\n  asciiUppercase: [[65, 91]],\n  digit: [[48, 58]],\n  whitespace: [[9, 14], [32, 33], [133, 134], [160, 161], [5760, 5761], [8192, 8203],\n               [8232, 8234], [8239, 8240], [8287, 8288], [12288, 12289]]\n}\n\nfunction isEmpty(expr: Expression) {\n  return expr instanceof SequenceExpression && expr.exprs.length == 0\n}\n\nfunction gatherExtTokens(b: Builder, tokens: readonly {id: Identifier, props: readonly Prop[]}[]) {\n  let result: {[name: string]: Term} = Object.create(null)\n  for (let token of tokens) {\n    b.unique(token.id)\n    let {name, props, dialect} = b.nodeInfo(token.props, \"d\", token.id.name)\n    let term = b.makeTerminal(token.id.name, name, props)\n    if (dialect != null) (b.tokens.byDialect[dialect] || (b.tokens.byDialect[dialect] = [])).push(term)\n    b.namedTerms[token.id.name] = result[token.id.name] = term\n  }\n  return result\n}\n\nfunction findExtToken(b: Builder, tokens: {[name: string]: Term}, expr: NameExpression) {\n  let found = tokens[expr.id.name]\n  if (!found) return null\n  if (expr.args.length) b.raise(\"External tokens cannot take arguments\", expr.args[0].start)\n  b.used(expr.id.name)\n  return found\n}\n\nfunction addRel(rel: {term: Term, after: readonly Term[]}[], term: Term, after: readonly Term[]) {\n  let found = rel.findIndex(r => r.term == term)\n  if (found < 0) rel.push({term, after})\n  else rel[found] = {term, after: rel[found].after.concat(after)}\n}\n\nclass ExternalTokenSet {\n  tokens: {[name: string]: Term}\n\n  constructor(readonly b: Builder, readonly ast: ExternalTokenDeclaration) {\n    this.tokens = gatherExtTokens(b, ast.tokens)\n    for (let name in this.tokens)\n      this.b.tokenOrigins[this.tokens[name].name] = {external: this}\n  }\n\n  getToken(expr: NameExpression) { return findExtToken(this.b, this.tokens, expr) }\n}\n\nclass ExternalSpecializer {\n  term: Term | null = null\n  tokens: {[name: string]: Term}\n\n  constructor(readonly b: Builder, readonly ast: ExternalSpecializeDeclaration) {\n    this.tokens = gatherExtTokens(b, ast.tokens)\n  }\n\n  finish() {\n    let terms = this.b.normalizeExpr(this.ast.token)\n    if (terms.length != 1 || terms[0].terms.length != 1 || !terms[0].terms[0].terminal)\n      this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`, this.ast.token.start)\n    this.term = terms[0].terms[0]\n    for (let name in this.tokens)\n      this.b.tokenOrigins[this.tokens[name].name] = {spec: this.term, external: this}\n  }\n\n  getToken(expr: NameExpression) { return findExtToken(this.b, this.tokens, expr) }\n}\n\nfunction inlineRules(rules: readonly Rule[], preserve: readonly Term[]): readonly Rule[] {\n  for (let pass = 0;; pass++) {\n    let inlinable: {[name: string]: readonly Rule[]} = Object.create(null), found\n    if (pass == 0) for (let rule of rules) {\n      if (rule.name.inline && !inlinable[rule.name.name]) {\n        let group = rules.filter(r => r.name == rule.name)\n        if (group.some(r => r.parts.includes(rule.name))) continue\n        found = inlinable[rule.name.name] = group\n      }\n    }\n    for (let i = 0; i < rules.length; i++) {\n      let rule = rules[i]\n      if (!rule.name.interesting && !rule.parts.includes(rule.name) && rule.parts.length < 3 &&\n          !preserve.includes(rule.name) &&\n          (rule.parts.length == 1 || rules.every(other => other.skip == rule.skip || !other.parts.includes(rule.name))) &&\n          !rule.parts.some(p => !!inlinable[p.name]) &&\n          !rules.some((r, j) => j != i && r.name == rule.name))\n        found = inlinable[rule.name.name] = [rule]\n    }\n    if (!found) return rules\n    let newRules = []\n    for (let rule of rules) {\n      if (inlinable[rule.name.name]) continue\n      if (!rule.parts.some(p => !!inlinable[p.name])) {\n        newRules.push(rule)\n        continue\n      }\n      function expand(at: number, conflicts: readonly Conflicts[], parts: readonly Term[]) {\n        if (at == rule.parts.length) {\n          newRules.push(new Rule(rule.name, parts, conflicts, rule.skip))\n          return\n        }\n        let next = rule.parts[at], replace = inlinable[next.name]\n        if (!replace) {\n          expand(at + 1, conflicts.concat(rule.conflicts[at + 1]), parts.concat(next))\n          return\n        }\n        for (let r of replace)\n          expand(at + 1,\n                 conflicts.slice(0, conflicts.length - 1)\n                 .concat(conflicts[at].join(r.conflicts[0]))\n                 .concat(r.conflicts.slice(1, r.conflicts.length - 1))\n                 .concat(rule.conflicts[at + 1].join(r.conflicts[r.conflicts.length - 1])),\n                 parts.concat(r.parts))\n      }\n      expand(0, [rule.conflicts[0]], [])\n    }\n    rules = newRules\n  }\n}\n\nfunction mergeRules(rules: readonly Rule[]): readonly Rule[] {\n  let merged: {[name: string]: Term} = Object.create(null), found\n  for (let i = 0; i < rules.length;) {\n    let groupStart = i\n    let name = rules[i++].name\n    while (i < rules.length && rules[i].name == name) i++\n    let size = i - groupStart\n    if (name.interesting) continue\n    for (let j = i; j < rules.length;) {\n      let otherStart = j, otherName = rules[j++].name\n      while (j < rules.length && rules[j].name == otherName) j++\n      if (j - otherStart != size || otherName.interesting) continue\n      let match = true\n      for (let k = 0; k < size && match; k++) {\n        let a = rules[groupStart + k], b = rules[otherStart + k]\n        if (a.cmpNoName(b) != 0) match = false\n      }\n      if (match) found = merged[name.name] = otherName\n    }\n  }\n  if (!found) return rules\n  let newRules = []\n  for (let rule of rules) if (!merged[rule.name.name]) {\n    newRules.push(rule.parts.every(p => !merged[p.name]) ? rule :\n                  new Rule(rule.name, rule.parts.map(p => merged[p.name] || p), rule.conflicts, rule.skip))\n  }\n  return newRules\n}\n\nfunction simplifyRules(rules: readonly Rule[], preserve: readonly Term[]): readonly Rule[] {\n  return mergeRules(inlineRules(rules, preserve))\n}\n\n/// Build an in-memory parser instance for a given grammar. This is\n/// mostly useful for testing. If your grammar uses external\n/// tokenizers or nested grammars, you'll have to provide the\n/// `externalTokenizer` and/or `nestedParser` options for the\n/// returned parser to be able to parse anything.\nexport function buildParser(text: string, options: BuildOptions = {}): Parser {\n  return new Builder(text, options).getParser()\n}\n\nconst KEYWORDS = [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\",\n                  \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"while\", \"with\",\n                  \"null\", \"true\", \"false\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"new\", \"in\", \"this\",\n                  \"const\", \"class\", \"extends\", \"export\", \"import\", \"super\", \"enum\", \"implements\", \"interface\",\n                  \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"]\n\n/// Build the code that represents the parser tables for a given\n/// grammar description. The `parser` property in the return value\n/// holds the main file that exports the `Parser` instance. The\n/// `terms` property holds a declaration file that defines constants\n/// for all of the named terms in grammar, holding their ids as value.\n/// This is useful when external code, such as a tokenizer, needs to\n/// be able to use these ids. It is recommended to run a tree-shaking\n/// bundler when importing this file, since you usually only need a\n/// handful of the many terms in your code.\nexport function buildParserFile(text: string, options: BuildOptions = {}): {parser: string, terms: string} {\n  return new Builder(text, options).getParserFile()\n}\n\nfunction ignored(name: string) {\n  let first = name[0]\n  return first == \"_\" || first.toUpperCase() != first\n}\n\nfunction isExported(rule: RuleDeclaration) {\n  return rule.props.some(p => p.at && p.name == \"export\")\n}\n"],"names":["none","sameSet","State","Conflict"],"mappings":"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"}