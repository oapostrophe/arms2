import { MapMode, ChangeDesc } from '@codemirror/state';

declare abstract class RangeValue {
    eq(other: RangeValue): boolean;
    startSide: number;
    endSide: number;
    mapMode: MapMode;
    point: boolean;
    range(from: number, to?: number): Range<this>;
}
declare class Range<T extends RangeValue> {
    readonly from: number;
    readonly to: number;
    readonly value: T;
}
interface RangeComparator<T extends RangeValue> {
    compareRange(from: number, to: number, activeA: T[], activeB: T[]): void;
    comparePoint(from: number, to: number, byA: T | null, byB: T | null): void;
}
interface SpanIterator<T extends RangeValue> {
    span(from: number, to: number, active: readonly T[], openStart: number): void;
    point(from: number, to: number, value: T, active: readonly T[], openStart: number): void;
}
interface RangeCursor<T> {
    next: () => void;
    value: T | null;
    from: number;
    to: number;
}
declare type RangeSetUpdate<T extends RangeValue> = {
    add?: readonly Range<T>[];
    sort?: boolean;
    filter?: (from: number, to: number, value: T) => boolean;
    filterFrom?: number;
    filterTo?: number;
};
declare class RangeSet<T extends RangeValue> {
    get size(): number;
    update<U extends T>(updateSpec: RangeSetUpdate<U>): RangeSet<T>;
    map(changes: ChangeDesc): RangeSet<T>;
    between(from: number, to: number, f: (from: number, to: number, value: T) => void | false): void;
    iter(from?: number): RangeCursor<T>;
    static iter<T extends RangeValue>(sets: readonly RangeSet<T>[], from?: number): RangeCursor<T>;
    static compare<T extends RangeValue>(oldSets: readonly RangeSet<T>[], newSets: readonly RangeSet<T>[], textDiff: ChangeDesc, comparator: RangeComparator<T>, minPointSize?: number): void;
    static spans<T extends RangeValue>(sets: readonly RangeSet<T>[], from: number, to: number, iterator: SpanIterator<T>, minPointSize?: number): number;
    static of<T extends RangeValue>(ranges: readonly Range<T>[] | Range<T>, sort?: boolean): RangeSet<T>;
    static empty: RangeSet<any>;
}
declare class RangeSetBuilder<T extends RangeValue> {
    private chunks;
    private chunkPos;
    private chunkStart;
    private last;
    private lastFrom;
    private lastTo;
    private from;
    private to;
    private value;
    private maxPoint;
    private setMaxPoint;
    private nextLayer;
    private finishChunk;
    constructor();
    add(from: number, to: number, value: T): void;
    finish(): RangeSet<T>;
}

export { Range, RangeComparator, RangeCursor, RangeSet, RangeSetBuilder, RangeValue, SpanIterator };
