import { NodeProp, NodeType, Input, ParseContext, PartialParse, Tree, TreeFragment, SyntaxNode } from 'lezer-tree';
import { Parser, ParserConfig } from 'lezer';
import { Facet, Extension, EditorState } from '@codemirror/state';
import { Line } from '@codemirror/text';

declare const languageDataProp: NodeProp<Facet<{
    [name: string]: any;
}, readonly {
    [name: string]: any;
}[]>>;
declare function defineLanguageFacet(baseData?: {
    [name: string]: any;
}): Facet<{
    [name: string]: any;
}, readonly {
    [name: string]: any;
}[]>;
declare class Language {
    readonly data: Facet<{
        [name: string]: any;
    }>;
    readonly topNode: NodeType;
    readonly extension: Extension;
    parser: {
        startParse: (input: Input, startPos: number, context: ParseContext) => PartialParse;
    };
    constructor(data: Facet<{
        [name: string]: any;
    }>, parser: {
        startParse(input: Input, pos: number, context: EditorParseContext): PartialParse;
    }, topNode: NodeType, extraExtensions?: Extension[]);
    isActiveAt(state: EditorState, pos: number): boolean;
    findRegions(state: EditorState): {
        from: number;
        to: number;
    }[];
    get allowsNesting(): boolean;
    parseString(code: string): Tree;
}
declare class LezerLanguage extends Language {
    readonly parser: Parser;
    private constructor();
    static define(spec: {
        parser: Parser;
        languageData?: {
            [name: string]: any;
        };
    }): LezerLanguage;
    configure(options: ParserConfig): LezerLanguage;
    get allowsNesting(): boolean;
}
declare function syntaxTree(state: EditorState): Tree;
declare function ensureSyntaxTree(state: EditorState, upto: number, timeout?: number): Tree | null;
declare class EditorParseContext implements ParseContext {
    private parser;
    readonly state: EditorState;
    fragments: readonly TreeFragment[];
    viewport: {
        from: number;
        to: number;
    };
    private parse;
    private withoutTempSkipped;
    skipUntilInView(from: number, to: number): void;
    static skippingParser: {
        startParse(input: Input, startPos: number, context: ParseContext): PartialParse;
    };
}
declare const language: Facet<Language, Language | null>;
declare class LanguageSupport {
    readonly language: Language;
    readonly support: Extension;
    extension: Extension;
    constructor(language: Language, support?: Extension);
}
declare class LanguageDescription {
    readonly name: string;
    readonly alias: readonly string[];
    readonly extensions: readonly string[];
    readonly filename: RegExp | undefined;
    private loadFunc;
    support: LanguageSupport | undefined;
    private loading;
    private constructor();
    load(): Promise<LanguageSupport>;
    static of(spec: {
        name: string;
        alias?: readonly string[];
        extensions?: readonly string[];
        filename?: RegExp;
        load: () => Promise<LanguageSupport>;
    }): LanguageDescription;
    static matchFilename(descs: readonly LanguageDescription[], filename: string): LanguageDescription | null;
    static matchLanguageName(descs: readonly LanguageDescription[], name: string, fuzzy?: boolean): LanguageDescription | null;
}

declare const indentService: Facet<(context: IndentContext, pos: number) => number | null, readonly ((context: IndentContext, pos: number) => number | null)[]>;
declare const indentUnit: Facet<string, string>;
declare function getIndentUnit(state: EditorState): number;
declare function indentString(state: EditorState, cols: number): string;
declare function getIndentation(context: IndentContext | EditorState, pos: number): number | null;
declare class IndentContext {
    readonly state: EditorState;
    unit: number;
    constructor(state: EditorState, options?: {
        overrideIndentation?: (pos: number) => number;
        simulateBreak?: number;
        simulateDoubleBreak?: boolean;
    });
    textAfterPos(pos: number): string;
    column(pos: number): number;
    countColumn(line: string, pos: number): number;
    lineIndent(line: Line): number;
}
declare const indentNodeProp: NodeProp<(context: TreeIndentContext) => number | null>;
declare class TreeIndentContext extends IndentContext {
    private base;
    readonly pos: number;
    readonly node: SyntaxNode;
    get textAfter(): string;
    get baseIndent(): number;
    continue(): number | null;
}
declare function delimitedIndent({ closing, align, units }: {
    closing: string;
    align?: boolean;
    units?: number;
}): (context: TreeIndentContext) => number;
declare const flatIndent: (context: TreeIndentContext) => number;
declare function continuedIndent({ except, units }?: {
    except?: RegExp;
    units?: number;
}): (context: TreeIndentContext) => number;
declare function indentOnInput(): Extension;

declare const foldService: Facet<(state: EditorState, lineStart: number, lineEnd: number) => ({
    from: number;
    to: number;
} | null), readonly ((state: EditorState, lineStart: number, lineEnd: number) => ({
    from: number;
    to: number;
} | null))[]>;
declare const foldNodeProp: NodeProp<(node: SyntaxNode, state: EditorState) => ({
    from: number;
    to: number;
} | null)>;
declare function foldInside(node: SyntaxNode): {
    from: number;
    to: number;
} | null;
declare function foldable(state: EditorState, lineStart: number, lineEnd: number): {
    from: number;
    to: number;
} | null;

export { EditorParseContext, IndentContext, Language, LanguageDescription, LanguageSupport, LezerLanguage, TreeIndentContext, continuedIndent, defineLanguageFacet, delimitedIndent, ensureSyntaxTree, flatIndent, foldInside, foldNodeProp, foldService, foldable, getIndentUnit, getIndentation, indentNodeProp, indentOnInput, indentService, indentString, indentUnit, language, languageDataProp, syntaxTree };
