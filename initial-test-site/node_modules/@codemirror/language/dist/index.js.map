{"version":3,"file":"index.js","sources":["../src/language.js","../src/indent.js","../src/fold.js"],"sourcesContent":["import { Tree, TreeFragment, NodeProp, NodeType } from \"lezer-tree\";\nimport { Text } from \"@codemirror/text\";\nimport { EditorState, StateField, StateEffect, Facet } from \"@codemirror/state\";\nimport { ViewPlugin } from \"@codemirror/view\";\n/// Node prop stored in a grammar's top syntax node to provide the\n/// facet that stores language data for that language.\nexport const languageDataProp = new NodeProp();\n/// Helper function to define a facet (to be added to the top syntax\n/// node(s) for a language via\n/// [`languageDataProp`](#language.languageDataProp)), that will be\n/// used to associate language data with the language. You\n/// probably only need this when subclassing\n/// [`Language`](#language.Language).\nexport function defineLanguageFacet(baseData) {\n    return Facet.define({\n        combine: baseData ? values => values.concat(baseData) : undefined\n    });\n}\n/// A language object manages parsing and per-language\n/// [metadata](#state.EditorState.languageDataAt). Parse data is\n/// managed as a [Lezer](https://lezer.codemirror.net) tree. You'll\n/// want to subclass this class for custom parsers, or use the\n/// [`LezerLanguage`](#language.LezerLanguage) or\n/// [`StreamLanguage`](#stream-parser.StreamLanguage) abstractions for\n/// [Lezer](https://lezer.codemirror.net/) or stream parsers.\nexport class Language {\n    /// Construct a language object. You usually don't need to invoke\n    /// this directly. But when you do, make sure you use\n    /// [`defineLanguageFacet`](#language.defineLanguageFacet) to create\n    /// the first argument.\n    constructor(\n    /// The [language data](#state.EditorState.languageDataAt) data\n    /// facet used for this language.\n    data, parser, \n    /// The node type of the top node of trees produced by this parser.\n    topNode, extraExtensions = []) {\n        this.data = data;\n        this.topNode = topNode;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!EditorState.prototype.hasOwnProperty(\"tree\"))\n            Object.defineProperty(EditorState.prototype, \"tree\", { get() { return syntaxTree(this); } });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            EditorState.languageData.of((state, pos) => state.facet(languageDataFacetAt(state, pos)))\n        ].concat(extraExtensions);\n    }\n    /// Query whether this language is active at the given position.\n    isActiveAt(state, pos) {\n        return languageDataFacetAt(state, pos) == this.data;\n    }\n    /// Find the document regions that were parsed using this language.\n    /// The returned regions will _include_ any nested languages rooted\n    /// in this language, when those exist.\n    findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)\n            return [{ from: 0, to: state.doc.length }];\n        if (!lang || !lang.allowsNesting)\n            return [];\n        let result = [];\n        syntaxTree(state).iterate({\n            enter: (type, from, to) => {\n                if (type.isTop && type.prop(languageDataProp) == this.data) {\n                    result.push({ from, to });\n                    return false;\n                }\n                return undefined;\n            }\n        });\n        return result;\n    }\n    /// Indicates whether this language allows nested languages. The\n    /// default implementation returns true.\n    get allowsNesting() { return true; }\n    /// Use this language to parse the given string into a tree.\n    parseString(code) {\n        let doc = Text.of(code.split(\"\\n\"));\n        let parse = this.parser.startParse(new DocInput(doc), 0, new EditorParseContext(this.parser, EditorState.create({ doc }), [], Tree.empty, { from: 0, to: code.length }, []));\n        let tree;\n        while (!(tree = parse.advance())) { }\n        return tree;\n    }\n}\n/// @internal\nLanguage.setState = StateEffect.define();\nfunction languageDataFacetAt(state, pos) {\n    let topLang = state.facet(language);\n    if (!topLang)\n        return null;\n    if (!topLang.allowsNesting)\n        return topLang.data;\n    let tree = syntaxTree(state);\n    let target = tree.resolve(pos, -1);\n    while (target) {\n        let facet = target.type.prop(languageDataProp);\n        if (facet)\n            return facet;\n        target = target.parent;\n    }\n    return topLang.data;\n}\n/// A subclass of [`Language`](#language.Language) for use with\n/// [Lezer](https://lezer.codemirror.net/docs/ref#lezer.Parser)\n/// parsers.\nexport class LezerLanguage extends Language {\n    constructor(data, parser) {\n        super(data, parser, parser.topNode);\n        this.parser = parser;\n    }\n    /// Define a language from a parser.\n    static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LezerLanguage(data, spec.parser.configure({\n            props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n        }));\n    }\n    /// Create a new instance of this language with a reconfigured\n    /// version of its parser.\n    configure(options) {\n        return new LezerLanguage(this.data, this.parser.configure(options));\n    }\n    get allowsNesting() { return this.parser.hasNested; }\n}\n/// Get the syntax tree for a state, which is the current (possibly\n/// incomplete) parse tree of active [language](#language.Language),\n/// or the empty tree if there is no language available.\nexport function syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : Tree.empty;\n}\n/// Try to get a parse tree that spans at least up to `upto`. The\n/// method will do at most `timeout` milliseconds of work to parse\n/// up to that point if the tree isn't already available.\nexport function ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    return !parse ? null : parse.tree.length >= upto || parse.work(timeout, upto) ? parse.tree : null;\n}\n// Lezer-style Input object for a Text document.\nclass DocInput {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.prevString = \"\";\n        this.cursor = doc.iter();\n    }\n    syncTo(pos) {\n        if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n            this.cursor = this.doc.iter();\n            this.cursorPos = 0;\n        }\n        this.prevString = pos == this.cursorPos ? this.string : \"\";\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    get(pos) {\n        if (pos >= this.length)\n            return -1;\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos) {\n            if (pos < stringStart && pos >= stringStart - this.prevString.length)\n                return this.prevString.charCodeAt(pos - (stringStart - this.prevString.length));\n            stringStart = this.syncTo(pos);\n        }\n        return this.string.charCodeAt(pos - stringStart);\n    }\n    lineAfter(pos) {\n        if (pos >= this.length || pos < 0)\n            return \"\";\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos)\n            stringStart = this.syncTo(pos);\n        return this.cursor.lineBreak ? \"\" : this.string.slice(pos - stringStart);\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.sliceString(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n    clip(at) {\n        return new DocInput(this.doc, at);\n    }\n}\n/// A parse context provided to parsers working on the editor content.\nexport class EditorParseContext {\n    /// @internal\n    constructor(parser, \n    /// The current editor state.\n    state, \n    /// Tree fragments that can be reused by incremental re-parses.\n    fragments = [], \n    /// @internal\n    tree, \n    /// The current editor viewport (or some overapproximation\n    /// thereof). Intended to be used for opportunistically avoiding\n    /// work (in which case\n    /// [`skipUntilInView`](#language.EditorParseContext.skipUntilInView)\n    /// should be called to make sure the parser is restarted when the\n    /// skipped region becomes visible).\n    viewport, \n    /// @internal\n    skipped) {\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.parse = null;\n        /// @internal\n        this.tempSkipped = [];\n    }\n    /// @internal\n    work(time, upto) {\n        if (this.tree != Tree.empty && (upto == null ? this.tree.length == this.state.doc.length : this.tree.length >= upto)) {\n            this.takeTree();\n            return true;\n        }\n        if (!this.parse)\n            this.parse = this.parser.startParse(new DocInput(this.state.doc), 0, this);\n        let endTime = Date.now() + time;\n        for (;;) {\n            let done = this.parse.advance();\n            if (done) {\n                this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done));\n                this.parse = null;\n                this.tree = done;\n                return true;\n            }\n            else if (upto != null && this.parse.pos >= upto) {\n                this.takeTree();\n                return true;\n            }\n            if (Date.now() > endTime)\n                return false;\n        }\n    }\n    /// @internal\n    takeTree() {\n        if (this.parse && this.parse.pos > this.tree.length) {\n            this.tree = this.parse.forceFinish();\n            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for (let r; r = this.tempSkipped.pop();)\n            fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /// @internal\n    changes(changes, newState) {\n        let { fragments, tree, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));\n            fragments = TreeFragment.applyChanges(fragments, ranges);\n            tree = Tree.empty;\n            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped) {\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to)\n                        skipped.push({ from, to });\n                }\n            }\n        }\n        return new EditorParseContext(this.parser, newState, fragments, tree, viewport, skipped);\n    }\n    /// @internal\n    updateViewport(viewport) {\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for (let i = 0; i < this.skipped.length; i++) {\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        return this.skipped.length < startLen;\n    }\n    /// @internal\n    reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /// Notify the parse scheduler that the given region was skipped\n    /// because it wasn't in view, and the parse should be restarted\n    /// when it comes into view.\n    skipUntilInView(from, to) {\n        this.skipped.push({ from, to });\n    }\n    /// @internal\n    movedPast(pos) {\n        return this.tree.length < pos && this.parse && this.parse.pos >= pos;\n    }\n}\n/// A parser intended to be used as placeholder when asynchronously\n/// loading a nested parser. It'll skip its input and mark it as\n/// not-really-parsed, so that the next update will parse it again.\nEditorParseContext.skippingParser = {\n    startParse(input, startPos, context) {\n        return {\n            pos: startPos,\n            advance() {\n                ;\n                context.tempSkipped.push({ from: startPos, to: input.length });\n                this.pos = input.length;\n                return new Tree(NodeType.none, [], [], input.length - startPos);\n            },\n            forceFinish() { return this.advance(); }\n        };\n    }\n};\nfunction cutFragments(fragments, from, to) {\n    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);\n}\nclass LanguageState {\n    constructor(\n    // A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context) {\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged)\n            return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.tree.length == tr.startState.doc.length ? undefined\n            : Math.max(tr.changes.mapPos(this.context.tree.length), newCx.viewport.to);\n        if (!newCx.work(25 /* Apply */, upto))\n            newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let parseState = new EditorParseContext(state.facet(language).parser, state, [], Tree.empty, { from: 0, to: state.doc.length }, []);\n        if (!parseState.work(25 /* Apply */))\n            parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = StateField.define({\n    create: LanguageState.init,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(Language.setState))\n                return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language))\n            return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback ||\n    ((callback, { timeout }) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\nconst parseWorker = ViewPlugin.fromClass(class ParseWorker {\n    constructor(view) {\n        this.view = view;\n        this.working = -1;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        if (update.viewportChanged) {\n            let cx = this.view.state.field(Language.state).context;\n            if (cx.updateViewport(update.view.viewport))\n                cx.reset();\n            if (this.view.viewport.to > cx.tree.length)\n                this.scheduleWork();\n        }\n        if (update.docChanged) {\n            if (this.view.hasFocus)\n                this.chunkBudget += 50 /* ChangeBonus */;\n            this.scheduleWork();\n        }\n    }\n    scheduleWork() {\n        if (this.working > -1)\n            return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree.length >= state.doc.length)\n            return;\n        this.working = requestIdle(this.work, { timeout: 500 /* Pause */ });\n    }\n    work(deadline) {\n        this.working = -1;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk\n            this.chunkEnd = now + 30000 /* ChunkTime */;\n            this.chunkBudget = 3000 /* ChunkBudget */;\n        }\n        if (this.chunkBudget <= 0)\n            return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree.length >= vpTo + 1000000 /* MaxParseAhead */)\n            return;\n        let time = Math.min(this.chunkBudget, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);\n        let done = field.context.work(time, vpTo + 1000000 /* MaxParseAhead */);\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {\n            field.context.takeTree();\n            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });\n        }\n        if (!done && this.chunkBudget > 0)\n            this.scheduleWork();\n    }\n    destroy() {\n        if (this.working >= 0)\n            cancelIdle(this.working);\n    }\n}, {\n    eventHandlers: { focus() { this.scheduleWork(); } }\n});\n/// The facet used to associate a language with an editor state.\nexport const language = Facet.define({\n    combine(languages) { return languages.length ? languages[0] : null; },\n    enables: [Language.state, parseWorker]\n});\n/// This class bundles a [language object](#language.Language) with an\n/// optional set of supporting extensions. Language packages are\n/// encouraged to export a function that optionally takes a\n/// configuration object and returns a `LanguageSupport` instance, as\n/// the main way for client code to use the package.\nexport class LanguageSupport {\n    /// Create a support object.\n    constructor(\n    /// The language object.\n    language, \n    /// An optional set of supporting extensions. When nesting a\n    /// language in another language, the outer language is encouraged\n    /// to include the supporting extensions for its inner languages\n    /// in its own set of support extensions.\n    support = []) {\n        this.language = language;\n        this.support = support;\n        this.extension = [language, support];\n    }\n}\n/// Language descriptions are used to store metadata about languages\n/// and to dynamically load them. Their main role is finding the\n/// appropriate language for a filename or dynamically loading nested\n/// parsers.\nexport class LanguageDescription {\n    constructor(\n    /// The name of this language.\n    name, \n    /// Alternative names for the mode (lowercased, includes `this.name`).\n    alias, \n    /// File extensions associated with this language.\n    extensions, \n    /// Optional filename pattern that should be associated with this\n    /// language.\n    filename, loadFunc) {\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        /// If the language has been loaded, this will hold its value.\n        this.support = undefined;\n        this.loading = null;\n    }\n    /// Start loading the the language. Will return a promise that\n    /// resolves to a [`LanguageSupport`](#language.LanguageSupport)\n    /// object when the language successfully loads.\n    load() {\n        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));\n    }\n    /// Create a language description.\n    static of(spec) {\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, spec.load);\n    }\n    /// Look for a language in the given array of descriptions that\n    /// matches the filename. Will first match\n    /// [`filename`](#language.LanguageDescription.filename) patterns,\n    /// and then [extensions](#language.LanguageDescription.extensions),\n    /// and return the first language that matches.\n    static matchFilename(descs, filename) {\n        for (let d of descs)\n            if (d.filename && d.filename.test(filename))\n                return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext)\n            for (let d of descs)\n                if (d.extensions.indexOf(ext[1]) > -1)\n                    return d;\n        return null;\n    }\n    /// Look for a language whose name or alias matches the the given\n    /// name (case-insensitively). If `fuzzy` is true, and no direct\n    /// matchs is found, this'll also search for a language whose name\n    /// or alias occurs in the string (for names shorter than three\n    /// characters, only when surrounded by non-word characters).\n    static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)\n            if (d.alias.some(a => a == name))\n                return d;\n        if (fuzzy)\n            for (let d of descs)\n                for (let a of d.alias) {\n                    let found = name.indexOf(a);\n                    if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length])))\n                        return d;\n                }\n        return null;\n    }\n}\n","import { NodeProp } from \"lezer-tree\";\nimport { EditorState, Transaction, Facet } from \"@codemirror/state\";\nimport { countColumn } from \"@codemirror/text\";\nimport { syntaxTree } from \"./language\";\n/// Facet that defines a way to provide a function that computes the\n/// appropriate indentation depth at the start of a given line, or\n/// `null` to indicate no appropriate indentation could be determined.\nexport const indentService = Facet.define();\n/// Facet for overriding the unit by which indentation happens.\n/// Should be a string consisting either entirely of spaces or\n/// entirely of tabs. When not set, this defaults to 2 spaces.\nexport const indentUnit = Facet.define({\n    combine: values => {\n        if (!values.length)\n            return \"  \";\n        if (!/^(?: +|\\t+)$/.test(values[0]))\n            throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return values[0];\n    }\n});\n/// Return the _column width_ of an indent unit in the state.\n/// Determined by the [`indentUnit`](#language.indentUnit)\n/// facet, and [`tabSize`](#state.EditorState^tabSize) when that\n/// contains tabs.\nexport function getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/// Create an indentation string that covers columns 0 to `cols`.\n/// Will use tabs for as much of the columns as possible when the\n/// [`indentUnit`](#language.indentUnit) facet contains\n/// tabs.\nexport function indentString(state, cols) {\n    let result = \"\", ts = state.tabSize;\n    if (state.facet(indentUnit).charCodeAt(0) == 9)\n        while (cols >= ts) {\n            result += \"\\t\";\n            cols -= ts;\n        }\n    for (let i = 0; i < cols; i++)\n        result += \" \";\n    return result;\n}\n/// Get the indentation at the given position. Will first consult any\n/// [indent services](#language.indentService) that are registered,\n/// and if none of those return an indentation, this will check the\n/// syntax tree for the [indent node prop](#language.indentNodeProp)\n/// and use that if found. Returns a number when an indentation could\n/// be determined, and null otherwise.\nexport function getIndentation(context, pos) {\n    if (context instanceof EditorState)\n        context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)) {\n        let result = service(context, pos);\n        if (result != null)\n            return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree ? syntaxIndentation(context, tree, pos) : null;\n}\n/// Indentation contexts are used when calling [indentation\n/// services](#language.indentService). They provide helper utilities\n/// useful in indentation logic, and can selectively override the\n/// indentation reported for some lines.\nexport class IndentContext {\n    /// Create an indent context.\n    constructor(\n    /// The editor state.\n    state, \n    /// @internal\n    options = {}) {\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /// Get the text directly after `pos`, either the entire line\n    /// or the next 100 characters, whichever is shorter.\n    textAfterPos(pos) {\n        var _a, _b;\n        let sim = (_a = this.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n        if (pos == sim && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak))\n            return \"\";\n        return this.state.sliceDoc(pos, Math.min(pos + 100, sim != null && sim > pos ? sim : 1e9, this.state.doc.lineAt(pos).to));\n    }\n    /// Find the column for the given position.\n    column(pos) {\n        var _a;\n        let line = this.state.doc.lineAt(pos), text = line.text.slice(0, pos - line.from);\n        let result = this.countColumn(text, pos - line.from);\n        let override = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation) ? this.options.overrideIndentation(line.from) : -1;\n        if (override > -1)\n            result += override - this.countColumn(text, text.search(/\\S/));\n        return result;\n    }\n    /// find the column position (taking tabs into account) of the given\n    /// position in the given string.\n    countColumn(line, pos) {\n        return countColumn(pos < 0 ? line : line.slice(0, pos), 0, this.state.tabSize);\n    }\n    /// Find the indentation column of the given document line.\n    lineIndent(line) {\n        var _a;\n        let override = (_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation;\n        if (override) {\n            let overriden = override(line.from);\n            if (overriden > -1)\n                return overriden;\n        }\n        return this.countColumn(line.text, line.text.search(/\\S/));\n    }\n}\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a column number or null, where null indicates that no\n/// definitive indentation can be determined.\nexport const indentNodeProp = new NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let tree = ast.resolve(pos);\n    // Enter previous nodes that end in empty error terms, which means\n    // they were broken off by error recovery, so that indentation\n    // works even if the constructs haven't been finished.\n    for (let scan = tree, scanPos = pos;;) {\n        let last = scan.childBefore(scanPos);\n        if (!last)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            tree = scan;\n            scanPos = last.from;\n        }\n        else {\n            scan = last;\n            scanPos = scan.to + 1;\n        }\n    }\n    return indentFrom(tree, pos, cx);\n}\nfunction ignoreClosed(cx) {\n    var _a, _b;\n    return cx.pos == ((_a = cx.options) === null || _a === void 0 ? void 0 : _a.simulateBreak) && ((_b = cx.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak);\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy)\n        return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction indentFrom(node, pos, base) {\n    for (; node; node = node.parent) {\n        let strategy = indentStrategy(node);\n        if (strategy)\n            return strategy(new TreeIndentContext(base, pos, node));\n    }\n    return null;\n}\nfunction topIndent() { return 0; }\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nexport class TreeIndentContext extends IndentContext {\n    /// @internal\n    constructor(base, \n    /// The position at which indentation is being computed.\n    pos, \n    /// The syntax tree node to which the indentation strategy\n    /// applies.\n    node) {\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.node = node;\n    }\n    /// Get the text directly after `this.pos`, either the entire line\n    /// or the next 100 characters, whichever is shorter.\n    get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /// Get the indentation at the reference line for `this.node`, which\n    /// is the line on which it starts, unless there is a node that is\n    /// _not_ a parent of this node covering the start of that line. If\n    /// so, the line at the start of that node is tried, again skipping\n    /// on if it is covered by another such node.\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.from);\n            while (atBreak.parent && atBreak.parent.from == atBreak.from)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line);\n    }\n    /// Continue looking for indentations in the node's parent nodes,\n    /// and return the result of that.\n    continue() {\n        let parent = this.node.parent;\n        return parent ? indentFrom(parent, this.pos, this.base) : 0;\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    var _a;\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken)\n        return null;\n    let sim = (_a = context.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for (let pos = openToken.to;;) {\n        let next = tree.childAfter(pos);\n        if (!next || next == last)\n            return null;\n        if (!next.type.isSkipped)\n            return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nexport function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned)\n        return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/// An indentation strategy that aligns a node's content to its base\n/// indentation.\nexport const flatIndent = (context) => context.baseIndent;\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nexport function continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/// Enables reindentation on input. When a language defines an\n/// `indentOnInput` field in its [language\n/// data](#state.EditorState.languageDataAt), which must hold a regular\n/// expression, the line at the cursor will be reindented whenever new\n/// text is typed and the input from the start of the line up to the\n/// cursor matches that regexp.\n///\n/// To avoid unneccesary reindents, it is recommended to start the\n/// regexp with `^` (usually followed by `\\s*`), and end it with `$`.\n/// For example, `/^\\s*\\}$/` will reindent when a closing brace is\n/// added at the start of a line.\nexport function indentOnInput() {\n    return EditorState.transactionFilter.of(tr => {\n        if (!tr.docChanged || tr.annotation(Transaction.userEvent) != \"input\")\n            return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length)\n            return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond)\n            return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some(r => r.test(lineStart)))\n            return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges) {\n            let line = state.doc.lineAt(head);\n            if (line.from == last)\n                continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null)\n                continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm)\n                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n        return changes.length ? [tr, { changes }] : tr;\n    });\n}\n","import { NodeProp } from \"lezer-tree\";\nimport { Facet } from \"@codemirror/state\";\nimport { syntaxTree } from \"./language\";\n/// A facet that registers a code folding service. When called with\n/// the extent of a line, such a function should return a foldable\n/// range that starts on that line (but continues beyond it), if one\n/// can be found.\nexport const foldService = Facet.define();\n/// This node prop is used to associate folding information with\n/// syntax node types. Given a syntax node, it should check whether\n/// that tree is foldable and return the range that can be collapsed\n/// when it is.\nexport const foldNodeProp = new NodeProp();\n/// [Fold](#language.foldNodeProp) function that folds everything but\n/// the first and the last child of a syntax node. Useful for nodes\n/// that start and end with delimiters.\nexport function foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length == 0)\n        return null;\n    let inner = tree.resolve(end);\n    let found = null;\n    for (let cur = inner; cur; cur = cur.parent) {\n        if (cur.to <= end || cur.from > end)\n            continue;\n        if (found && cur.from < start)\n            break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end)\n                found = value;\n        }\n    }\n    return found;\n}\n/// Check whether the given line is foldable. First asks any fold\n/// services registered through\n/// [`foldService`](#language.foldService), and if none of them return\n/// a result, tries to query the [fold node\n/// prop](#language.foldNodeProp) of syntax nodes that cover the end\n/// of the line.\nexport function foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)) {\n        let result = service(state, lineStart, lineEnd);\n        if (result)\n            return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\n"],"names":[],"mappings":"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"}