import { RangeSet, RangeValue, Range } from '@codemirror/rangeset';
export { Range } from '@codemirror/rangeset';
import { EditorState, Extension, Transaction, ChangeSet, EditorSelection, TransactionSpec, SelectionRange, Facet, StateEffectType } from '@codemirror/state';
import { Line } from '@codemirror/text';
import { StyleModule, StyleSpec } from 'style-mod';

declare type Attrs = {
    [name: string]: string;
};

interface MarkDecorationSpec {
    inclusive?: boolean;
    inclusiveStart?: boolean;
    inclusiveEnd?: boolean;
    attributes?: {
        [key: string]: string;
    };
    class?: string;
    tagName?: string;
    [other: string]: any;
}
interface WidgetDecorationSpec {
    widget: WidgetType;
    side?: number;
    block?: boolean;
    [other: string]: any;
}
interface ReplaceDecorationSpec {
    widget?: WidgetType;
    inclusive?: boolean;
    inclusiveStart?: boolean;
    inclusiveEnd?: boolean;
    block?: boolean;
    [other: string]: any;
}
interface LineDecorationSpec {
    attributes?: {
        [key: string]: string;
    };
    [other: string]: any;
}
declare abstract class WidgetType {
    abstract toDOM(view: EditorView): HTMLElement;
    eq(_widget: WidgetType): boolean;
    updateDOM(_dom: HTMLElement): boolean;
    get estimatedHeight(): number;
    ignoreEvent(_event: Event): boolean;
}
declare type DecorationSet = RangeSet<Decoration>;
declare enum BlockType {
    Text = 0,
    WidgetBefore = 1,
    WidgetAfter = 2,
    WidgetRange = 3
}
declare abstract class Decoration extends RangeValue {
    readonly spec: any;
    abstract eq(other: Decoration): boolean;
    static mark(spec: MarkDecorationSpec): Decoration;
    static widget(spec: WidgetDecorationSpec): Decoration;
    static replace(spec: ReplaceDecorationSpec): Decoration;
    static line(spec: LineDecorationSpec): Decoration;
    static set(of: Range<Decoration> | readonly Range<Decoration>[], sort?: boolean): DecorationSet;
    static none: DecorationSet;
}

interface Rect {
    readonly left: number;
    readonly right: number;
    readonly top: number;
    readonly bottom: number;
}

declare type Command = (target: EditorView) => boolean;
declare function logException(state: EditorState, exception: any, context?: string): void;
interface PluginValue {
    update?(_update: ViewUpdate): void;
    destroy?(): void;
}
declare const isFieldProvider: unique symbol;
declare class PluginFieldProvider<V> {
    private [isFieldProvider];
}
declare class PluginField<T> {
    from<V extends PluginValue>(get: (value: V) => T): PluginFieldProvider<V>;
    static define<T>(): PluginField<T>;
    static decorations: PluginField<DecorationSet>;
    static scrollMargins: PluginField<Partial<Rect> | null>;
}
interface PluginSpec<V extends PluginValue> {
    eventHandlers?: DOMEventHandlers<V>;
    decorations?: (value: V) => DecorationSet;
    provide?: PluginFieldProvider<V> | readonly PluginFieldProvider<V>[];
}
declare class ViewPlugin<V extends PluginValue> {
    extension: Extension;
    private constructor();
    static define<V extends PluginValue>(create: (view: EditorView) => V, spec?: PluginSpec<V>): ViewPlugin<V>;
    static fromClass<V extends PluginValue>(cls: {
        new (view: EditorView): V;
    }, spec?: PluginSpec<V>): ViewPlugin<V>;
}
interface MeasureRequest<T> {
    read(view: EditorView): T;
    write(measure: T, view: EditorView): void;
    key?: any;
}
declare class ViewUpdate {
    readonly view: EditorView;
    readonly state: EditorState;
    readonly transactions: readonly Transaction[];
    readonly changes: ChangeSet;
    readonly startState: EditorState;
    get viewportChanged(): boolean;
    get heightChanged(): boolean;
    get geometryChanged(): boolean;
    get focusChanged(): boolean;
    get docChanged(): boolean;
    get selectionSet(): boolean;
}

interface MouseSelectionStyle {
    get: (curEvent: MouseEvent, extend: boolean, multiple: boolean) => EditorSelection;
    update: (update: ViewUpdate) => void;
}
declare type MakeSelectionStyle = (view: EditorView, event: MouseEvent) => MouseSelectionStyle | null;

declare enum Direction {
    LTR = 0,
    RTL = 1
}
declare class BidiSpan {
    readonly from: number;
    readonly to: number;
    readonly level: number;
    get dir(): Direction;
}

declare class BlockInfo {
    readonly from: number;
    readonly length: number;
    readonly top: number;
    readonly height: number;
    readonly type: BlockType | readonly BlockInfo[];
    get to(): number;
    get bottom(): number;
}

interface EditorConfig {
    state?: EditorState;
    root?: Document | ShadowRoot;
    dispatch?: (tr: Transaction) => void;
    parent?: Element;
}
declare class EditorView {
    get state(): EditorState;
    get viewport(): {
        from: number;
        to: number;
    };
    get visibleRanges(): readonly {
        from: number;
        to: number;
    }[];
    get inView(): boolean;
    get composing(): boolean;
    private _dispatch;
    readonly root: DocumentOrShadowRoot;
    readonly dom: HTMLElement;
    readonly scrollDOM: HTMLElement;
    readonly contentDOM: HTMLElement;
    private announceDOM;
    private plugins;
    private editorAttrs;
    private contentAttrs;
    private styleModules;
    private bidiCache;
    constructor(config?: EditorConfig);
    dispatch(tr: Transaction): void;
    dispatch(...specs: TransactionSpec[]): void;
    update(transactions: readonly Transaction[]): void;
    setState(newState: EditorState): void;
    private updatePlugins;
    get themeClasses(): string;
    private updateAttrs;
    private showAnnouncements;
    private mountStyles;
    private readMeasured;
    requestMeasure<T>(request?: MeasureRequest<T>): void;
    pluginField<T>(field: PluginField<T>): readonly T[];
    plugin<T>(plugin: ViewPlugin<T>): T | null;
    blockAtHeight(height: number, editorTop?: number): BlockInfo;
    visualLineAtHeight(height: number, editorTop?: number): BlockInfo;
    viewportLines(f: (line: BlockInfo) => void, editorTop?: number): void;
    visualLineAt(pos: number, editorTop?: number): BlockInfo;
    get contentHeight(): number;
    moveByChar(start: SelectionRange, forward: boolean, by?: (initial: string) => (next: string) => boolean): SelectionRange;
    moveByGroup(start: SelectionRange, forward: boolean): SelectionRange;
    moveToLineBoundary(start: SelectionRange, forward: boolean, includeWrap?: boolean): SelectionRange;
    moveVertically(start: SelectionRange, forward: boolean, distance?: number): SelectionRange;
    scrollPosIntoView(pos: number): void;
    domAtPos(pos: number): {
        node: Node;
        offset: number;
    };
    posAtDOM(node: Node, offset?: number): number;
    posAtCoords(coords: {
        x: number;
        y: number;
    }): number | null;
    coordsAtPos(pos: number, side?: -1 | 1): Rect | null;
    get defaultCharacterWidth(): number;
    get defaultLineHeight(): number;
    get textDirection(): Direction;
    get lineWrapping(): boolean;
    bidiSpans(line: Line): readonly BidiSpan[];
    get hasFocus(): boolean;
    focus(): void;
    destroy(): void;
    static styleModule: Facet<StyleModule, readonly StyleModule[]>;
    static domEventHandlers(handlers: DOMEventHandlers<any>): Extension;
    static inputHandler: Facet<(view: EditorView, from: number, to: number, text: string) => boolean, readonly ((view: EditorView, from: number, to: number, text: string) => boolean)[]>;
    static exceptionSink: Facet<(exception: any) => void, readonly ((exception: any) => void)[]>;
    static updateListener: Facet<(update: ViewUpdate) => void, readonly ((update: ViewUpdate) => void)[]>;
    static editable: Facet<boolean, boolean>;
    static mouseSelectionStyle: Facet<MakeSelectionStyle, readonly MakeSelectionStyle[]>;
    static dragMovesSelection: Facet<(event: MouseEvent) => boolean, readonly ((event: MouseEvent) => boolean)[]>;
    static clickAddsSelectionRange: Facet<(event: MouseEvent) => boolean, readonly ((event: MouseEvent) => boolean)[]>;
    static decorations: Facet<DecorationSet, readonly DecorationSet[]>;
    static theme(spec: {
        [selector: string]: StyleSpec;
    }, options?: {
        dark?: boolean;
    }): Extension;
    static baseTheme(spec: {
        [selector: string]: StyleSpec;
    }): Extension;
    static contentAttributes: Facet<Attrs, Attrs>;
    static editorAttributes: Facet<Attrs, Attrs>;
    static lineWrapping: Extension;
    static announce: StateEffectType<string>;
}
interface DOMEventMap extends HTMLElementEventMap {
    [other: string]: any;
}
declare type DOMEventHandlers<This> = {
    [event in keyof DOMEventMap]?: (this: This, event: DOMEventMap[event], view: EditorView) => boolean | void;
};

interface KeyBinding {
    key?: string;
    mac?: string;
    win?: string;
    linux?: string;
    run: Command;
    shift?: Command;
    scope?: string;
    preventDefault?: boolean;
}
declare const keymap: Facet<readonly KeyBinding[], readonly (readonly KeyBinding[])[]>;
declare function runScopeHandlers(view: EditorView, event: KeyboardEvent, scope: string): boolean;

declare type SelectionConfig = {
    cursorBlinkRate?: number;
    drawRangeCursor?: boolean;
};
declare function drawSelection(config?: SelectionConfig): Extension;

interface SpecialCharConfig {
    render?: ((code: number, description: string | null, placeholder: string) => HTMLElement) | null;
    specialChars?: RegExp;
    addSpecialChars?: RegExp | null;
}
declare function highlightSpecialChars(config?: SpecialCharConfig): Extension;

declare function highlightActiveLine(): Extension;

declare function placeholder(content: string | HTMLElement): Extension;

declare class MatchDecorator {
    private regexp;
    private getDeco;
    private boundary;
    constructor(config: {
        regexp: RegExp;
        decoration: Decoration | ((match: RegExpExecArray, view: EditorView, pos: number) => Decoration);
        boundary?: RegExp;
    });
    createDeco(view: EditorView): RangeSet<Decoration>;
    updateDeco(update: ViewUpdate, deco: DecorationSet): DecorationSet;
    private updateRange;
}

export { BidiSpan, BlockInfo, BlockType, Command, DOMEventHandlers, DOMEventMap, Decoration, DecorationSet, Direction, EditorView, KeyBinding, MatchDecorator, MouseSelectionStyle, PluginField, PluginFieldProvider, PluginSpec, PluginValue, Rect, ViewPlugin, ViewUpdate, WidgetType, drawSelection, highlightActiveLine, highlightSpecialChars, keymap, logException, placeholder, runScopeHandlers };
